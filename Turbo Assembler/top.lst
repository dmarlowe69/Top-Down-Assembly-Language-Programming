   1                   ;.PAGE 'TOP64'
   2                   ;.OPT LIST
   3                   ;****************************
   4                   ;TOP-DOWN ASSEMBLY LANGUAGE
   5                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   6                   ;
   7                   ;BY KEN SKIER
   8                   ;
   9                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
  10                   ;
  11                   ;LEXINGTON, MASSACHUSETTS
  12                   ;
  13                   ;SOURCE CODE ENTERED AND EDITED BY
  14                   ;
  15                   ; WILLIAM DENTON MARLOWE
  16                   ; APRIL 2016 
  17                   ;*********************************
  18                   *=$0801         ;START OF BASIC
  19                   ;*********************************
  20                   ; SET BSTUB TO ONE TO ALLOW FOR
  21                   ; INSERTION OF BASIC STUB CODE
  22                   ;*********************************
  23                   BSTUB = 1
  24                   ;*********************************
  25                   ; 10 SYS (2063)
  26                   ;*********************************
  27                   .ifne BSTUB
  28 0801 0d 08         .WORD BASIC    ;NEXT LINE POINTER
  29 0803 0a 00         .BYTE $0A,$00  ;LINE NUMBER (10)
  30 0805 9e            .BYTE 158      ;SYS COMMAND TOKEN
  31 0806 28 32 30 36   .TEXT "(2063)" ;ASCII (2063)
     080a 33 29 
  32 080c 00            .BYTE 0        ;(0) END OF LINE
  33 080d 00 00        BASIC .BYTE 0,0 ;END OF BASIC
  34                   .endif
  35                   ;****************************
  36                   ;
  37                   ;****************************
  38                   XX080F =*
  39 080f 4c a5 08            JMP ENTRY
  40                   ;****************************
  41                   ;SYSTEM DATA BLOCK
  42                   ;FOR THE COMMODORE 64
  43                   ;****************************
  44                   .include "APPENDIXB2.ASM"
   1                   ;********************************************
   2                   ;SYSTEM DATA BLOCK FOR THE COMMODORE 64
   3                   ;
   4                   ;APPENDIX C14: ASSEMBLER LISTING OF
   5                   ;SYSTEM DATA BLOCK
   6                   ;FOR THE COMMODORE 64
   7                   ;SEE APPENDIX B2 OF TOP-DOWN ASSEMBLY LANGUAGE
   8                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   9                   ;BY KEN SKIER
  10                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
  11                   ;LEXINGTON, MASSACHUSETTS
  12                   ;
  13                   ;********************************************
  14                   
  15                   ;********************************************
  16                   ;
  17                   ; C64 HARDWIRE MEMORY LOCATION DEFINITIONS
  18                   ;
  19                   ;********************************************
  20                   
  21                   KERNAL = $E000
  22                   KEREND = $E0FF
  23                   
  24                   FRERAM = $C100
  25                   FRETOP = $C1FF
  26                   FREBOT = $C400
  27                   
  28                   ;********************************************
  29                   ;
  30                   ; C64 ZEROPAGE STORAGE
  31                   ;
  32                   ;********************************************
  33                   TVPTR  = $FB      ;POINTER TO CURRENT SCREEN
  34                                     ;LOCATION.
  35                   GETPTR = $FD      ;
  36                   
  37                   PUTPTR = $FB      ;POINTER TO CURRENT SCREEN
  38                                     ;LOCATION.
  39                   ;********************************************
  40                   ;
  41                   ;EXTERNAL VECTORS
  42                   ;
  43                   ;********************************************
  44                   ;VISMON = $3207     ;TOP LEVEL OF THE VISIBLE
  45                   ;                   ;MONITOR.
  46                   ;HEXPG = $3500       ;ADDRESS OF PAGE IN WHICH
  47                   ;                   ;HEXDUMP CODE STARTS.
  48                   ;********************************************
  49                   ;
  50                   ;EXTERNAL MEMORY DEFINITIONS
  51                   ;
  52                   ;********************************************
  53 0812 00 e0        SA .WORD $E000
  54 0814 ff ff        EA .WORD $FFFF
  55                   ;********************************************
  56                   ;
  57                   ;C64 KERNAL ROUTINES
  58                   ;
  59                   ;********************************************
  60                   CHKOUT = $FFC9
  61                   CHROUT = $FFD2
  62                   CLOSE  = $FFC3
  63                   OPEN   = $FFC0
  64                   SAVE   = $FFDB
  65                   SETLFS = $FFBA
  66                   SETNAM = $FFBD
  67                   ;********************************************
  68                   ;
  69                   ;STARING ADDRESS DEFINTION
  70                   ;
  71                   ;********************************************
  72                   ;* = $3000
  73                   ;********************************************
  74                   ;
  75                   ;CONSTANTS DEFINITIONS
  76                   ;
  77                   ;********************************************
  78                   TEX = $7F      ;THIS CHARACTER MUST START
  79                                  ;ANY MESSAGE.
  80                   ETX = $FF      ;THIS CHARACTER MUST
  81                                  ;TERMINATE ANY MESSAGE STRING.
  82                   ;********************************************
  83                   ;
  84                   ;CHARACTER DEFINITIONS
  85                   ;
  86                   ;********************************************
  87                   SPACE  = $20   ;ASCII FOR SPACE BAR.
  88                   RUBOUT = $7F   ;ASCII FOR BACKSPACE ERASE.
  89                   CR     = $0D   ;ASCII FOR CARRIAGE RETURN.
  90                   LF     = $0A   ;ASCII FOR LINE FEED.
  91                   CLRKEY = 147   ;CLEAR SCREEN KEY
  92                   ;********************************************
  93                   ;
  94                   ;SCREEN PARAMETERS
  95                   ;
  96                   ;********************************************
  97 0816 00 04        HOME   .WORD $0400 ;THIS IS THE ADDRESS OF THE
  98                                      ;CHARACTER IN THE UPPER LEFT
  99                                      ;CORNER OF THE SCREEN. 
 100 0818 28           ROWINC .BYTE 40    ;ADDRESS DIFFERENCE FROM ONE
 101                                      ;ROW TO THE NEXT.
 102 0819 27           TVCOLS .BYTE 39    ;NUMBER OF COLUMNS ON SCREEN,
 103                                      ;COUNTING FROM ZERO.
 104 081a 18           TVROWS .BYTE 24    ;NUMBER OF ROWS ON SCREEN,
 105                                      ;COUNTING FROM ZERO.
 106 081b 07           HIPAGE .BYTE $07   ;HIGHEST PAGE IN SCREEN MEMORY.
 107 081c 20           BLANK  .BYTE $20   ;C64 DISPLAY CODE FOR A BLANK.
 108                                      ;(IN NORMAL VIDEO MODE.)
 109 081d 1e           ARROW  .BYTE $1E   ;C64 DISPLAY CODE FOR UP-ARROW.
 110                   ;********************************************
 111                   ;
 112                   ;INPUT/OUTPUT VECTORS
 113                   ;
 114                   ;********************************************
 115 081e 4b 08        ROMKEY .WORD C64KEY ;POINTER TO ROUTINE THAT GETS
 116                                       ;AN ASCII CHARACTER FROM THE
 117                                       ;KEYBOARD. (NOTES C64KEY
 118                                       ;CALLS A ROM SUBROUTINE, BUT
 119                                       ;C64KEY IS NOT A C64 ROM
 120                                       ;SUBROUTINE.)
 121 0820 52 08        ROMTVT .WORD C64TVT ;POINTER TO ROUTINE TO PRINT
 122                                       ;PAN ASCII CHARACTER ON THE SCREEN
 123 0822 57 08        ROMPRT .WORD C64PRT ;POINTER TO ROUTINE TO SEND AN
 124                                       ;ASCII CHARACTER TO THE PRINTER
 125 0824 26 08        USROUT .WORD DUMMY  ;POINTER TO USER-WRITTEN OUTPUT
 126                                       ;ROUTINE. (SET HERE TO DUMMY
 127                                       ;UNTIL YOU SET IT TO POINT
 128                                       ;TO YOUR OWN CHARACTER-OUTPUT
 129                                       ;ROUTINE.)
 130 0826 60           DUMMY   RTS         ;THIS IS A DUMMY SUBROUTINE.
 131                                       ;IT DOES NOTHING BUT RETURN.
 132                   ;********************************************
 133                   ;CONVERT ASCII CHARACTER TO DISPLAY CODE
 134                   ;FIXCHR
 135                   ;
 136                   ;********************************************
 137                                      ;A CHARACTER IB IN A. WE
 138                                      ;MUST CONVERT IT TO PROPER
 139                                      ;C64 DISPLAY CODE.
 140                                      ;BUT FIRST, PUT A COLOR CODE
 141                                      ;IN APPROPRIATE BYTE OF
 142                                      ;COLOR MEMORY. (OTHERWISE,
 143                                      ;THAT BYTE IN COLOR MEMORY
 144                                      ;MIGHT BE ZERO, RENDERING
 145                                      ;THE CHARACTER INVISIBLE.)
 146                   
 147 0827 48           FIXCHR PHA          ;SAVE THE CHARACTER TO BE
 148                                       ;DISPLAYED.
 149 0828 a5 fc               LDA TVPTR+1  ;SAVE HIGH BYTE...
 150 082a 48                  PHA          ;...OF TVPTR.
 151 082b 18                  CLC          ;MAKE TVPTR POINT
 152 082c 69 d4               ADC #$D4     ;TO APPROPRIATE BYTE
 153 082e 85 fc               STA TVPTR+1  ;OF COLOR MEMORY.
 154 0830 a0 00               LDY #0       ;
 155 0832 ad 86 02            LDA $286     ;GET CURRENT COLOR CODE.
 156                                       ;STORE IT IN APPROPRIATE
 157                                       ;BYTE OF COLOR MEMORY:
 158 0835 91 fb               STA (TVPTR),Y
 159                                       ;
 160 0837 68                  PLA          ;RESTORE HIGH BYTE OF TV.PTR
 161 0838 85 fc               STA TVPTR+1  ;TO ITS ORIGINAL VALUE.
 162                                       ;
 163 083a 68                  PLA          ;RETRIEVE CHARACTER TO BE
 164                                       ;DISPLAYED.
 165 083b 38                  SEC          ;PREPARE TO COMPARE.
 166 083c c9 40               CMP #$40     ;IS IT LESS THAN $40? (IS
 167                                       ;IT A NUMBER OR A PUNCTUATION
 168                                       ;MARK?).
 169 083e 90 0a               BCC FIXEND   ;IF SO, NO CONVERSION NEEDED.
 170                                       ;
 171 0840 c9 60               CMP #$60     ;IS IT IN THE RANGE $40...$5F?
 172                                       ;
 173 0842 90 03               BCC SUB40    ;IF SO, SUBTRACT $40 TO
 174                                       ;CONVERT FROM ASCII TO C64.
 175                                       ;IT'S > $5F.
 176                                       ;
 177 0844 e9 20               SBC #$20     ;SUBTRACT $20 TO CONVERT
 178                                       ;LOWER CASE ASCII TO C64 CODE.
 179                                       ;
 180 0846 60                  RTS          ;AND RETURN.
 181                                       ;
 182 0847 38           SUB40  SEC          ;PREPARE TO SUBTRACT.
 183 0848 e9 40               SBC #$40     ;SUBTRACT $40 TO CONVERT ASCII
 184                                       ;UPPERCASE CHAR TO C-64 CODE.
 185 084a 60           FIXEND RTS          ;RETURN, WITH A HOLDING
 186                                       ;C-64 SCREEN CODE FOR ASCII
 187                                       ;CHAR ORIGINALLY IN A.
 188                   ;********************************************
 189                   ;
 190                   ;GET AN ASCII CHARACTER FROM THE KEYBOARD
 191                   ;
 192                   ;********************************************
 193 084b 20 e4 ff     C64KEY JSR $FFE4   ;GET A KEYBOARD CHARACTER.
 194 084e aa                  TAX         ;IS IT ZERO?
 195 084f f0 fa               BEQ C64KEY  ;ZERO MEANS NO KEY, SO
 196                                      ;SCAN AGAIN.
 197 0851 60                  RTS         ;RETURN WITH ASCII CHARACTER
 198                                      ;FROM THE KEYBOARD.
 199                   ;********************************************
 200                   ;
 201                   ;PRINT AN ASCII CHARACTER ON THE SCREEN
 202                   ;
 203                   ;********************************************
 204 0852 a2 01        C64TVT LDX #1     ;WE'LL DEFINE LOGICAL FILE #1
 205                                     ;AS AN OUTPUT CHANNEL.
 206                                     ;
 207 0854 4c 59 08            JMP OUTCHR ;OUTPUT THE CHARACTER IN A ON
 208                                     ;LOGICAL FILE "X".
 209                   ;********************************************
 210                   ;
 211                   ;PRINT AN ASCII CHARACTER ON A PRINTER
 212                   ;
 213                   ;********************************************
 214                                     ;THIS PROCEDURE ASSUMES THAT
 215                                     ;THE USER HAS USED BASIC TO
 216                                     ;OPEN A DEVICE OR FILE AS
 217                                     ;LOGICAL FILE #2, BEFORE
 218                                     ;CALLING THE VJSIBLE MONITOR.
 219                                     ;LOGICAL FILE #2 MIGHT BE A
 220                                     ;PRINTER, OR THE RS-232 PORT,
 221                                     ;OR EVEN A DISK OR CASSETTE
 222                                     ;FILE. THE IMPORTANT THING IS
 223                                     ;THAT IT'S OPEN, SO WE MAY
 224                                     ;OUTPUT TEXT TO IT.
 225                                     ;
 226 0857 a2 02        C64PRT LDX #2     ;WE'LL DEFINE LOGICAL FILE #2
 227                                     ;AS AN OUTPUT CHANNEL.
 228                                     ;NOW OUTPUT CHARACTER IN A ON
 229                                     ;LOGICAL FILE "X":
 230 0859 48           OUTCHR PHA        ;SAVE CHARACTER TO BE OUTPUT.
 231                                     ;
 232 085a 20 c9 ff            JSR CHKOUT ;SET LOGICAL FILE "X11 FOR OUTPUT.
 233                                      ;
 234 085d 68                  PLA        ;RETRIEVE CHARACTER TO BE SENT.
 235                                     ;
 236 085e 20 d2 ff            JSR CHROUT ;OUTPUT CHARACTER IN A ON
 237                                     ;THE CURRENTLY-OPEN CHANNEL.
 238                                     ;
 239 0861 60                  RTS        ;AND RETURN.
 240                   ;********************************************
 241                   ;
 242                   ;SAVE A MACHINE LANGUAGE PROGRAM
 243                   ;ON TAPE OR DISK
 244                   ;
 245                   ;********************************************
 246                                      ;THE FOLLOWING VARIABLES
 247                                      ;MUST BE SET, EITHER BY THE
 248                                      ;VISIBLE MONITOR OR BY A
 249                                      ;BASIC PROGRAM, BEFORE MLSAVE
 250                                      ;MAY BE CALLED.
 251                                      ;
 252 0862 01           DEVICE .BYTE 1     ;DEVICE TO BE USED FOR SAVE.
 253                                      ;1 SPECIFIES DATASETTE.
 254                                      ;8 SPECIFIES DISK DRIVE.
 255                                      ;
 256 0863 00           LENGTH .BYTE 0     ;LENGTH OF FILENAME.
 257                   ;
 258                   
 259                   
 260 0864 00 00 00 00 
 261 0868 00 00 00 00 
 262 086c 00 00 00 00 
 263 0870 00 00 00 00 
 264 0874 00 00 00 00 
 265                   
 266                   ;NOTE: THE POINTERS SA AND EA
 267                   ;STARTING AND ENDING ADDRESSES
 268                   ;(RESPECTIVELY) OK THE PROGRAM
 269                   ;TO BE SAVED- THEY MAY BE SET
 270                   ;MOST CONVENIENTLY BY SIMPLY
 271                   ;CALLING THE SUBROUTINE "SETADS"
 272                   ;AT *35E3 (13795 DECIMAL).
 273                   
 274                   ;STARTING AND ENDING ADDRESSES
 275                   ;(RESPECTIVELY) OK THE PROGRAM
 276                   ;TO BE SAVED- THEY MAY BE SET
 277                   ;MOST CONVENIENTLY BY SIMPLY
 278                   ;CALLING THE SUBROUTINE "SETADS"
 279                   ;AT *35E3 (13795 DECIMAL).
 280                   
 281 0878 a9 03        MLSAVE LDA #3      ;LOGICAL FILE NUMBER.
 282 087a ae 62 08            LDX DEVICE  ;DEVICE NUMBER.
 283 087d a8                  TAY         ;SECONDARY ADDRESS.
 284 087e 20 ba ff            JSR SETLFS  ;CALL KERNAL ROUTINE "SETLFS".
 285                                      ;NOW THE C64 KNOWS WHAT DEVICE
 286                                      ;TO USE.
 287                                      ;
 288 0881 ad 63 08            LDA LENGTH  ;GET LENGTH OF FILENAME.
 289                                      ;
 290 0884 a2 64               LDX #<NAME
 291 0886 a0 08               LDY #>NAME
 292                                      ;NOW (X,Y> POINTS TU THE FILE
 293                                      ;NAME.
 294 0888 20 bd ff            JSR SETNAM  ;CALL KERNAL ROUTINE "SETNAM".
 295                                      ;NOW THE C64 KNOWS THE NAME OF
 296                                      ;THE FILE YOU WISH TO CREATE.
 297                                      ;
 298 088b ad 12 08            LDA SA
 299 088e 85 fd               STA $FD
 300 0890 ad 13 08            LDA SA+1
 301 0893 85 fe               STA $FE    ;NOW PTR AT $FD POINTS TO START
 302                                     ;OF THE ML PROGRAM.
 303 0895 a9 fd               LDA #$FD   ;NOW A HOLDS ZERO PAGE OFFSET
 304                                     ;FOR THAT POINTER.
 305 0897 ae 14 08            LDX EA     ;NOW (X,Y) POINTS TO THE END OF
 306 089a ac 15 08            LDY EA+1   ;THE ML PROGRAM.
 307                                     ;BUT THE KERNAL ROUTINE "SAVE"
 308                                     ;REQUIRES THAT (X,Y) POINT ONE
 309                                     ;BYTE BEYOND THE END OF THE
 310                                     ;ML PROGRAM. SO INCREMENT
 311                                     ;(X,Y):
 312 089d e8                  INX
 313 089e d0 01               BNE XYSET
 314 08a0 c8                  INY        ;
 315                                     ;NOW (X,Y) IS SET.
 316                                     ;
 317 08a1 20 db ff     XYSET JSR SAVE   ;CALL KERNAL ROUTINE "SAVE".
 318                                     ;THIS ACTUALLY OPENS A FILE AND
 319                                     ;STORES THE SPECIFIED PORTION OF
 320                                     ;MEMORY ON THE SPECIFIED DEVICE.
 321                                     ;
 322 08a4 60                  RTS        ;RETURN TO CALLER (PRESUMABLY
 323                                     ;BASIC OR THE VISIBLE MONITOR
 324                   ;********************************************
 325                   ;
 326                   ;VISIBLE MONITOR:ENTRY FROM BASIC
 327                   ;
 328                   ;********************************************
 329 08a5 a9 00        ENTRY  LDA #0      ;
 330 08a7 48                  PHA         ;
 331 08a8 28                  PLP         ;NOW THE STATUS REGISTER IS
 332                                      ;ZERO.
 333                                      ;
 334                                      ;OPEN THE SCREEN AS LOGICAL
 335                                      ;FILE #1:D 
 336                                      ;
 337 08a9 20 bd ff            JSR SETNAM  ;A ALREADY HOLDS $00,
 338                                      ;INDICATING NO FILE NAME.
 339                                      ;
 340 08ac a9 01               LDA #1      ;LOGICAL FILE NUMBER.
 341 08ae a2 00               LDX #0      ;DEVICE NUMBER OF THE SCREEN.
 342 08b0 a0 ff               LDY #255    ;(NO COMMAND.)
 343 08b2 20 ba ff            JSR SETLFS  ;C64 KERNAL ROUTINE "SETLFS"
 344                                      ;
 345 08b5 20 c0 ff            JSR OPEN    ;NOW THE SCREEN IS LOGICAL FILE
 346                                      ;#1.
 347                                      ;
 348 08b8 20 e2 18            JSR INITBUF ;INITIALIZE TEXT EDITOR BUFFER
 349                                      ;
 350 08bb a9 16               LDA #<HOME  ;INIT TVPRT WITH HOME SCREEN ADDRESS
 351 08bd 85 fb               STA TVPTR   ;
 352 08bf a9 08               LDA #>HOME  ;
 353 08c1 85 fc               STA TVPTR+1 ;
 354                   
 355 08c3 a9 00               LDA #<KERNAL ;INIT TVPRT WITH HOME SCREEN ADDRESS
 356 08c5 8d c5 09            STA SELECT   ;
 357 08c8 a9 e0               LDA #>KERNAL ;
 358 08ca 8d c6 09            STA SELECT+1 ;
 359                   
 360 08cd a9 00               LDA #<KERNAL ;INIT TVPRT WITH HOME SCREEN ADDRESS
 361 08cf 85 fd               STA GETPTR   ;
 362 08d1 a9 e0               LDA #>KERNAL ;
 363 08d3 85 fe               STA GETPTR+1 ;
 364                   
 365 08d5 20 da 09            JSR VISMON  ;CALL THE VISIBLE MONITOR.
 366                                      ;
 367                                      ;NOW THE VISIBLE MONITOR HAS
 368                                      ;RETURNED.
 369                                      ;
 370 08d8 a9 01               LDA #1      ;SO CLOSE LOGICAL FILE #1:
 371 08da 20 c3 ff            JSR CLOSE   ;
 372                                      ;
 373 08dd 60                  RTS         ;RETURN TO CALLER (PRESUMABLY
 374                                      ;BASIC.)
 375                   ;********************************************
 376                   ;
 377                   ;
 378                   ;
 379                   ;********************************************
 381                   
  45                   ;*********************************
  46                   ; SET FLAGS TO ONE TO ALLOW FOR
  47                   ; INSERTION CHAPTER CODE
  48                   ;*********************************
  49                   CHAP5  = 1
  50                   CHAP6  = 1
  51                   CHAP7  = 1
  52                   CHAP8  = 1
  53                   CHAP9  = 1
  54                   CHAP10 = 1
  55                   CHAP11 = 1
  56                   CHAP12 = 1
  57                   ;****************************
  58                   ;SCREEN UTILITIES
  59                   ;****************************
  60                   .ifne CHAP5
  61                   .include "CHAPTER5.ASM"
   1                   ;********************************************
   2                   ;SCREEN UTILITIES
   3                   ;
   4                   ;APPENDIX Cl: ASSEMBLER LISTING OF
   5                   ;SCREEN UTILITIES
   6                   ;SEE CHAPTER 5 OF TOP-DOWN ASSEMBLY LANGUAGE
   7                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   8                   ;BY KEN SKIER
   9                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
  10                   ;LEXINGTON, MASSACHUSETTS
  11                   ;********************************************
  12                   ;ASCII:  RETURN ASCII CHARACTER FOR 4 LSB IN A.
  13                   ;CENTER: SET CURRENT SCREEN POSITION TO CENTER OF SCREEN.
  14                   ;CLRTV:  CLEAR THE ENTIRE VIDEO DISPLAY, PRESERVING TVPTR.
  15                   ;CLRXY:  CLEAR A RECTANGLE OF THE SCREEN, WITH X,Y DIMENSIONS SPECIFIED
  16                   ;        BY THE X,Y REGISTERS.
  17                   ;TVDOWN: MOVE CURRENT SCREEN POSITION DOWN BY ONE ROW.
  18                   ;TVHOME: SET CURRENT SCREEN POSITION TO THE UPPER-LEFT CORNER OF THE
  19                   ;        SCREEN.
  20                   ;TVPLUS: ADD A TO TVPTR.
  21                   ;TVPOP:  RESTORE PREVIOUSLY SAVED SCREEN POSITION FROM STACK.
  22                   ;TVPUSH: SAVE CURRENT SCREEN LOCATION ON STACK.
  23                   ;TVPUT:  DISPLAY ASCII CHARACTER IN A AT CURRENT SCREEN LOCATION.
  24                   ;TVSKIP: ADVANCE TO NEXT SCREEN LOCATION.
  25                   ;TVTOXY: SET CURRENT SCREEN POSITION TO X,Y COORDINATES GIVEN BY X,Y
  26                   ;        REGISTERS.
  27                   ;VUBYTE: DISPLAY A, IN HEXADECIMAL FORM, AT CURRENT SCREEN LOCATION.
  28                   ;        ADVANCE CURRENT SCREEN LOCATION PAST THE DISPLAYED BYTE.
  29                   ;VUCHAR: DISPLAY A AS AN ASCII CHARACTER IN CURRENT SCREEN LOCATION;
  30                   ;        THEN ADVANCE TO NEXT SCREEN LOCATION.;APPENDIX CL: ASSEMBLER LISTING OF
  31                   ;********************************************
  32                   ;ZERO PAGE BYTES
  33                   ;********************************************
  34                   ;TVPTR = $FB ;THIS POINTER HOLDS THE
  35                   ;             ;ADDRESS OF THE CURRENT
  36                   ;             ;SCREEN LOCATION.
  37                   ;********************************************
  38                   ;SCREEN PARAMETERS
  39                   ;********************************************
  40                   ;PARAMS = $3000 ;THE FOLLOWING ADDRESSES
  41                   ;               ;MUST BE INITIALIZED TO HOLD
  42                   ;               ;DATA DESCRIBING THE SCREEN
  43                   ;               ;ON YOUR SYSTEM.
  44                   ;HOME = PARAMS  ;HOME IS A POINTER TO CHARACTER
  45                   ;               ;POSITION IN UPPER LEFT CORNER.
  46                   ;ROWINC = PARAMS+2 ;ROWINC IS A BYTE GIVING
  47                   ;                  ;ADDRESS DIFFERENCE FROM ONE
  48                   ;                  ;ROW TO THE NEXT.
  49                   ;TVCOLS = PARAMS+3 ;TVCOLS IS A BYTE GIVING
  50                   ;                  ;NUMBER OF COLUMNS ON SCREEN.
  51                   ;                  ;(COUNTING FROM ZERO.)
  52                   ;TVROWS = PARAMS+4 ;FVROWS IS A BYTE GIVING
  53                   ;                  ;NUMBER OF ROWS ON SCREEN,
  54                   ;                  ;(COUNTING FROM ZERO.)
  55                   ;HIPAGE = PARAMS+5 ;HIPAGE IS THE HIGH BYTE OF
  56                   ;                  ;THE HIGHEST ADDRESS ON SCREEN.
  57                   ;BLANK = PARAMS+6  ;YOUR SYSTEM'S CHARACTER
  58                   ;                  ;CODE FOR A BLANK.
  59                   ;ARROW = PARAMS+7  ;YOUR SYSTEM S CHARACTER
  60                   ;                  ;FOR AN UP-ARROW.
  61                   ;FIXCHR = PARAMS+$11 ;FIXCHR IS A SUBROUTINE THAT
  62                   ;                    ;RETURNS YOUR SYSTEM'S
  63                   ;                    ;DISPLAY CODE FOR ASCII.
  64                   ;                    ;CODE.
  65                   ;********************************************
  66                   ; * = $3100
  67                   ;********************************************
  68                   ;CLEAR SCREEN
  69                   ;
  70                   ;CLEAR SCREEN, PRESERVING THE ZERO PAGE.
  71                   ;
  72                   ;********************************************
  73 08de 20 a2 09     CLRTV  JSR TVPUSH  ;SAVE ZERO PAGE BYTES THAT
  74                                      ;WILL BE CHANGED.
  75 08e1 20 09 09            JSR TVHOME  ;SET SCREEN LOCATION TO UPPER
  76                                      ;LEFT CORNER OF THE SCREEN.
  77 08e4 ae 19 08            LDX TVCOLS  ;LOAD X,Y REGISTERS WITH
  78 08e7 ac 1a 08            LDY TVROWS  ;X,Y DIMENSIONS OF SCREEN.
  79 08ea 20 f1 08            JSR CLRXY   ;CLEAR X COLUMNS, Y ROWS
  80                                      ;FROM CURRENT SCREEN LOCATION.
  81 08ed 20 b1 09            JSR TVPOP   ;RESTORE ZERO PAGE BYTES THAT
  82                                      ;WERE CHANGED.
  83 08f0 60                  RTS         ;RETURN TO CALLER, WITH ZERO
  84                                      ;PAGE PRESERVED.
  85                   ;********************************************
  86                   ;
  87                   ;CLEAR PORTION OF SCREEN
  88                   ;
  89                   ;CLEAR X COLUMNS, Y ROWS
  90                   ;FROM CURRENT SCREEN LOCATION.
  91                   ;MOVES TVPTR DOWN BY Y ROWS.
  92                   ;
  93                   ;********************************************
  94 08f1 8e 08 09     CLRXY  STX COLS      ;SET THE NUMBER OF COLUMNS
  95                                        ;TO BE CLEARED.
  96 08f4 98                  TYA
  97 08f5 aa                  TAX           ;NOW X HOLDS NUMBER OF ROWS
  98                                        ;TO BE CLEARED.
  99                   ;
 100 08f6 ad 1c 08     CLRROW LDA BLANK     ;WE'LL CLEAR THEM BY
 101                                        ;WRITING BLANKS TO THE
 102                                        ;SCREEN.
 103 08f9 ac 08 09            LDY COLS      ;LOAD Y WITH NUMBER OF
 104                                        ;COLUMNS TO BE CLEARED.
 105 08fc 91 fb        CLRPOS STA (TVPTR),Y ;CLEAR A POSITION BY
 106                                        ;WRITING A BLANK INTO IT.
 107                   ;
 108 08fe 88                  DEY           ;ADJUST INDEX FOR NEXT
 109                                        ;POSITION ON THE ROW.
 110 08ff 10 fb               BPL CLRPOS    ;IF NOT DONE WITH ROW,
 111                                        ;CLEAR NEXT POSITION...
 112 0901 20 54 09            JSR TVDOWN    ;IF DONE WITH ROW, MOVE
 113                                        ;CURRENT SCREEN LOCATION
 114                                        ;DOWN BY ONE ROW.
 115                   ;
 116 0904 ca                  DEX           ;DONE LAST ROW YET?
 117 0905 10 ef               BPL CLRROW    ;IF NOT, CLEAR NEXT ROW...
 118 0907 60                  RTS           ;IF SO, RETURN TO CALLER.
 119 0908 00           COLS   .BYTE 0       ;DATA CELLS HOLDS NUMBER OF
 120                                        ;COLUMNS TO BE CLEARED.
 121                   ;********************************************
 122                   ;
 123                   ;TVHOME
 124                   ;
 125                   ;********************************************
 126 0909 a2 00        TVHOME LDX #0     ;SET TVPTR TO UPPER LEFT
 127 090b a0 00               LDY #0     ;CORNER OF SCREEN BY
 128                                     ;ZEROING X AND Y AND THEN
 129 090d 18                  CLC        ;GOING TO X,Y COORDINATES
 130 090e 90 0a               BCC TVTOXY ;
 131                   ;********************************************
 132                   ;
 133                   ;CENTER
 134                   ;
 135                   ;SET TVPTR TO SCREEN'S
 136                   ;CENTER
 137                   ;
 138                   ;********************************************
 139 0910 ad 1a 08     CENTER LDA TVROWS  ;LOAD A WITH TOTAL ROWS.
 140 0913 4a                  LSR A       ;DIVIDE IT BY TWO.
 141 0914 a8                  TAY         ;Y NOW HOLDS THE NUMBER OF THE CENTRAL
 142                                      ;ROW ON THE SCREEN.
 143 0915 ad 19 08            LDA TVCOLS  ;LOAD A WITH TOTAL COLUMNS.
 144 0918 4a                  LSR A       ;DIVIDE IT BY TWO.
 145 0919 aa                  TAX         ;X NOW HOLDS THE NUMBER OF THE CENTRAL
 146                                      ;COLUMN ON THE SCREEN.
 147                                      ;NOW X AND Y REGISTERS HOLD X, Y COOR-
 148                                      ;DINATES OF CENTER OF SCREEN.
 149                   ;********************************************
 150                   ;
 151                   ;TVTOXY
 152                   ;
 153                   ;SET CURRENT SCREEN LOCATION
 154                   ;TO COORDINATES GIVEN BY
 155                   ;THE X AND Y REGISTERS.
 156                   ;
 157                   ;********************************************
 158 091a 38           TVTOXY SEC         ;
 159 091b ec 19 08            CPX TVCOLS  ;IS X OUT OF RANGE?
 160 091e 90 03               BCC XOK     ;IF NOT, LEAVE IT ALONE.
 161                                      ;IF X IS OUT OF RANGE, GIVE
 162 0920 ae 19 08            LDX TVCOLS  ;IT ITS MAXIMUM LEGAL VALUE
 163                                      ;NOW X IS LEGAL.
 164 0923 38           XOK    SEC         ;IS Y OUT OF RANGE?
 165 0924 cc 1a 08            CPY TVROWS  ;
 166 0927 90 03               BCC YOK     ;IF NOT, LEAVE IT ALONE.
 167                                      ;IF Y IS OUT OF RANGE, GIVE
 168 0929 ac 1a 08            LDY TVROWS  ;IT ITS MAXIMUM LEGAL VALUE
 169                                      ;NOW Y IS LEGAL.
 170 092c ad 16 08     YOK    LDA HOME    ;SET TVPTR = HOME.
 171 092f 85 fb               STA TVPTR   ;
 172 0931 ad 17 08            LDA HOME+1  ;
 173 0934 85 fc               STA TVPTR+1 ;
 174                                      ;
 175 0936 08                  PHP
 176 0937 d8                  CLD
 177                                      ;
 178 0938 8a                  TXA         ;ADD X TO TVPTR.
 179 0939 18                  CLC         ;
 180 093a 65 fb               ADC TVPTR   ;
 181 093c 90 03               BCC COLSET  ;
 182 093e e6 fc               INC TVPTR+1 ;
 183 0940 18                  CLC         ;
 184                                      ;
 185 0941 c0 00        COLSET CPY #0      ;ADD Y*ROWINC TO TVPTR
 186 0943 f0 0b               BEQ TVSET   ;
 187 0945 18           ADDROW CLC         ;
 188 0946 6d 18 08            ADC ROWINC  ;
 189 0949 90 02               BCC *+4     ;
 190 094b e6 fc               INC TVPTR+1 ;
 191 094d 88           NEXT1  DEY         ;
 192 094e d0 f5               BNE ADDROW  ;
 193                   ;
 194 0950 85 fb        TVSET  STA TVPTR   ;
 195 0952 28                  PLP         ;RESTORE CALLER'S DECIMAL FLAG
 196 0953 60                  RTS         ;RETURN TO CALLER.
 197                   ;********************************************
 198                   ;
 199                   ;TVDOWN, TVSKIP, AND TVPLUS
 200                   ;
 201                   ;********************************************
 202 0954 ad 18 08     TVDOWN LDA ROWINC  ;MOVE TVPTR DOWN BY ONE ROW.
 203 0957 18                  CLC         ;
 204 0958 90 05               BCC TVPLUS  ;UNCONDITIONALLY BRANCH.
 205                   ;
 206 095a 20 79 09     VUCHAR JSR TVPUT   ;PUT CHARACTER ON SCREEN,
 207                                      ;AND THEN
 208                                      ;
 209 095d a9 01        TVSKIP LDA #1      ;SKIP ONE SCREEN LOCATION
 210                                      ;BY INCREMENTING TV.PTR
 211                                      ;
 212 095f 08           TVPLUS PHP         ;TVPLUS ADDS ACCUMULATOR
 213 0960 d8                  CLD         ;TO TV.PTR, KEEPING TV.PTR
 214 0961 18                  CLC         ;WITHIN SCREEN MEMORY.
 215 0962 65 fb               ADC TVPTR   ;
 216 0964 90 02               BCC *+4     ;
 217 0966 e6 fc               INC TVPTR+1 ;
 218 0968 85 fb               STA TVPTR   ;
 219 096a 38                  SEC         ;IS CURRENT SCREEN LOCATION
 220 096b ad 1b 08            LDA HIPAGE  ;OUTSIDE OF SCREEN MEMORY?
 221 096e c5 fc               CMP TVPTR+1 ;
 222 0970 b0 05               BCS TVOK    ;
 223                                      ;
 224 0972 ad 17 08            LDA HOME+1  ;IF SO, WRAP AROUND FROM
 225 0975 85 fc               STA TVPTR+1 ;BOTTOM TO TOP OF SCREEN.
 226                                      ;
 227 0977 28           TVOK   PLP         ;RESTORE ORIGINAL DECIMAL
 228 0978 60                  RTS         ;FLAG AND RETURN TO CALLER.
 229                   ;********************************************
 230                   ;
 231                   ;TVPUT
 232                   ;
 233                   ;********************************************
 234 0979 20 27 08     TVPUT  JSR FIXCHR    ;CONVERT ASCII CHARACTER
 235                                        ;TO YOUR SYSTEM'S DISPLAY
 236                                        ;CODE.
 237                                        ;
 238 097c a0 00        TVPUTX LDY #0        ;PUT CHARACTER AT CURRENT
 239 097e 91 fb               STA (TVPTR),Y ;SCREEN LOCATION.
 240 0980 60                  RTS           ;THEN RETURN.
 241                   ;********************************************
 242                   ;
 243                   ;VUBYTE
 244                   ;
 245                   ;********************************************
 246 0981 48           VUBYTE PHA         ;SAVE BYTE TO BE DISPLAYED.
 247 0982 4a                  LSR A       ;MOVE 4 MOST SIGNIFICANT
 248 0983 4a                  LSR A       ;BITS INTO POSITIONS
 249 0984 4a                  LSR A       ;FORMERLY OCCUPIED BY 4
 250 0985 4a                  LSR A       ;LEAST SIGNIFICANT BITS.
 251                                      ;
 252 0986 20 94 09            JSR ASCII   ;DETERMINE ASCII CHAR FOR
 253                                      ;HEX DIGIT IN A'S 4 LSB.
 254                                      ;
 255 0989 20 5a 09            JSR VUCHAR  ;DISPLAY THAT ASCII CHAR ON
 256                                      ;SCREEN AND ADVANCE TO NEXT
 257                                      ;SCREEN LOCATION.
 258                                      ;
 259 098c 68                  PLA         ;RESTORE ORIGINAL BYTE TO A.
 260 098d 20 94 09            JSR ASCII   ;DETERMINE ASCII CHAR FOR
 261                                      ;A'S 4 LSB.
 262                                      ;
 263 0990 20 5a 09            JSR VUCHAR  ;STORE THIS ASCII CHAR JUST
 264                                      ;TO THE RIGHT OF THE OTHER
 265                                      ;ASCII CHAR, AND ADVANCE TO
 266                                      ;NEXT SCREEN POSITION.
 267 0993 60                  RTS         ;RETURN TO CALLER.
 268                   ;********************************************
 269                   ;
 270                   ;ASCII
 271                   ;
 272                   ;********************************************
 273 0994 08           ASCII  PHP        ;THIS ROUTINE RETURNS ASCII
 274 0995 d8                  CLD        ;FOR 4 LSB IN ACCUMULATOR.
 275 0996 29 0f               AND #$0F   ;CLEAR HIGH 4 BITS IN A.
 276 0998 c9 0a               CMP #$0A   ;IS ACCUMULATOR GREATER
 277                                     ;THAN 9?
 278 099a 30 02               BMI DECIML ;IF NOT, IT MUST BE 0-9.
 279                                     ;
 280 099c 69 06               ADC #6     ;IF SO, IT MUST BE A-F.
 281                                     ;ADD 36 HEX TO CONVERT IT.
 282                                     ;TO CORRESPONDING ASCII CHAR.
 283 099e 69 30        DECIML ADC #$30   ;IF A IS 0-9, ADD 30 HEX
 284                                     ;TO CONVERT IT TO
 285                                     ;CORRESPONDING ASCII CHAR.
 286                                     ;
 287 09a0 28                  PLP        ;RESTORE ORIGINAL DECIMAL
 288                                     ;FLAG, AND
 289 09a1 60                  RTS        ;RETURN TO CALLER
 290                   ;********************************************
 291                   ;
 292                   ;TVPUSH
 293                   ;
 294                   ;SAVE CURRENT SCREEN LOCATION
 295                   ;ON STACK, FOR CALLER.
 296                   ;********************************************
 297 09a2 68           TVPUSH PLA         ;PULL RETURN ADDRESS FROM STACK.
 298 09a3 aa                  TAX         ;SAVE IT IN X...
 299 09a4 68                  PLA
 300 09a5 a8                  TAY         ;...AND IN Y.
 301                                      ;
 302 09a6 a5 fc               LDA TVPTR+1 ;GET TVPTR
 303 09a8 48                  PHA         ;AND SAVE
 304 09a9 a5 fb               LDA TVPTR   ;IT ON
 305 09ab 48                  PHA         ;THE STACK.
 306                                      ;
 307 09ac 98                  TYA         ;PLACE RETURN
 308 09ad 48                  PHA         ;ADDRESS BACK...
 309 09ae 8a                  TXA
 310 09af 48                  PHA         ;... ON STACK.
 311                                      ;
 312 09b0 60                  RTS         ;THEN RETURN TO CALLER.
 313                   ;********************************************
 314                   ;
 315                   ;TVPOP
 316                   ;
 317                   ;********************************************
 318 09b1 68           TVPOP  PLA         ;PULL RETURN ADDRESS FROM STACK.
 319 09b2 aa                  TAX         ;SAVE IT IN X...
 320 09b3 68                  PLA         ;
 321 09b4 a8                  TAY         ;...AND IN Y.
 322                                      ;
 323 09b5 68                  PLA         ;RESTORE...
 324 09b6 85 fb               STA TVPTR   ;...TVPTR
 325 09b8 68                  PLA         ;...FROM
 326 09b9 85 fc               STA TVPTR+1 ;...STACK.
 327                                      ;
 328 09bb 98                  TYA         ;PLACE RETURN
 329 09bc 48                  PHA         ;ADDRESS BACK...
 330 09bd 8a                  TXA         ;
 331 09be 48                  PHA         ;... ON STACK.
 332                                      ;
 333 09bf 60                  RTS         ;THEN RETURN TO CALLER.
 334                   ;********************************************
 335                   ;
 336                   ;
 337                   ;
 338                   ;********************************************
 340                   
  62                   .endif
  63                   ;****************************
  64                   ; VISIBLE MONITOR
  65                   ;****************************
  66                   .ifne CHAP6
  67                   .include "CHAPTER6.ASM"
   1                   ;********************************************
   2                   ;VISIBLE MONITOR
   3                   ;
   4                   ;APPENDIX C2: ASSEMBLER LISTING OF
   5                   ;THE VISIBLE MONITOR
   6                   ;TOP LEVEL AND DISPLAY SUBROUTINES
   7                   ;SEE CHAPTER 6 OF TOP-DOWN ASSEMBLY LANGUAGE
   8                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC
   9                   ;BY KEN SKIER
  10                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
  11                   ;LEXINGTON, MASSACHUSETTS
  12                   ;********************************************
  13                   ;BINARY   DETERMINE WHETHER ACCUMULATOR HOLDS THE ASCII REPRESEN-
  14                   ;         TATION FOR A HEXADECIMAL DIGIT. IF SO, RETURN BINARY REPRESEN-
  15                   ;         TATION FOR THAT DIGIT. IF NOT, RETURN AN ERROR CODE ($FF).
  16                   ;CALLSL   CALL THE CURRENTLY SELECTED ADDRESS AS A SUBROUTINE.
  17                   ;DECSL   SELECT PREVIOUS ADDRESS, BY DECREMENTING SELECT POINTER.
  18                   ;GETKEY   GET A CHARACTER FROM THE KEYBOARD BY CALLING MACHINE'S
  19                   ;         READ-ONLY MEMORY ROUTINE INDIRECTLY.
  20                   ;GETSL   GET BYTE AT CURRENTLY SELECTED ADDRESS.
  21                   ;GO       LOAD REGISTERS FROM DISPLAYED IMAGES AND CALL DISPLAYED AD-
  22                   ;         DRESS. UPON RETURN, RESTORE REGISTER IMAGES FROM REGISTERS.
  23                   ;INCSL   SELECT NEXT BYTE (INCREMENT SELECT POINTER).
  24                   ;PUTSL   STORE ACCUMULATOR AT CURRENTLY SELECTED ADDRESS.
  25                   ;VISMON   LET USER GIVE THE VISIBLE MONITOR COMMANDS UNTIL USER
  26                   ;         PRESSES 'Q' TO QUIT.
  27                   ;********************************************
  28                   ;
  29                   ;VARIABLES
  30                   ;
  31                   ;********************************************
  32 09c0 00           FIELD  .BYTE 0 ;FIELD HOLDS THE NUMBER OF THE CURRENT
  33                                  ;FIELD.
  34 09c1 00           REGA   .BYTE 0 ;REGA HOLDS THE IMAGE OF REGISTER A
  35                                  ;(THE ACCUMULATOR).
  36 09c2 00           REGX   .BYTE 0 ;REGX HOLDS THE IMAGE OF REGISTER X.
  37 09c3 00           REGY   .BYTE 0 ;REGY HOLDS THE IMAGE OF REGISTER Y.
  38 09c4 00           REGP   .BYTE 0 ;REGP HOLDS THE IMAGE OF THE PROCESSOR
  39                                  ;STATUS REGISTER.
  40                   REGS = REGA    ;
  41                                  ;
  42 09c5 00 00        SELECT .WORD 0 ;THIS POINTS TO THE CURRENTLY SELECTED
  43                                  ;BYTE.
  44                   ;
  45 09c7 00           LBLCOL .BYTE 0          ;THIS IS A COUNTER.
  46 09c8 41 20 20 58  LABELS .TEXT "A  X  Y  P"  ;THESE ARE THE CHARACTERS
     09cc 20 20 59 20 
     09d0 20 50 
  47 09d2 03 06 08     FIELDS .BYTE 3,6,8   ;THIS DATA AREA SHOWS WHICH COLUMN
  48 09d5 0b 0e               .BYTE $0B,$0E ;SHOULD GET AN UP-ARROW TO INDICATE
  49 09d7 11 14               .BYTE $11,$14 ;OF THESE VALUES WILL CAUSE THE UP-ARROW
  50                                        ;TO APPEAR IN A DIFFERENT COLUMN WHEN IN-
  51                                        ;DICATING A GIVEN FIELD.
  52 09d9 00           TEMP   .BYTE 0       ;THIS BYTE HOLDS THE TEMPORARY VARIABLE
  53                                        ;USED BY ROLSL.
  54                   ;********************************************
  55                   ;
  56                   ;THE VISIBLE MONITOR
  57                   ;
  58                   ;********************************************
  59                   VISMON =*          ;
  60 09da d8                  CLD         ;CLEAR DECIMAL MODE, SINCE
  61                                      ;ARITHMETIC OPERATIONS IN THIS
  62                                      ;BOOK ARE ALWAYS BINARY.
  63                                      ;
  64 09db 20 99 0a            JSR LDREG   ;LOAD REGISTER IMAGES
  65                                      ;
  66 09de 20 e7 09     LOOPV  JSR DSPLAY  ;PUT MONITOR DISPLAY ON SCREEN.
  67                                      ;
  68                          ;JSR TVDUMP  ;
  69                                      ;
  70 09e1 20 ab 0a            JSR UPDATE  ;GET USER REQUEST AND HANDLE IT.
  71                                      ;       
  72 09e4 18                  CLC         ;
  73 09e5 90 f7               BCC LOOPV   ;LOOP BACK TO DISPLAY...
  74                   ;********************************************
  75                   ;
  76                   ;MONITOR-DISPLAY
  77                   ;
  78                   ;********************************************
  79 09e7 20 a2 09     DSPLAY JSR TVPUSH  ;SAVE ZERO PAGE BYTES THAT
  80                                      ;WILL BE MODIFIED.
  81                                      ;
  82                          ;JSR CLRTV  ;
  83                                      ;
  84 09ea 20 fa 09            JSR CLRMON  ;CLEAR MONITOR'S PORTION OF SCREEN.
  85 09ed 20 0a 0a            JSR LINEL   ;DISPLAY THE LABEL LINE.
  86 09f0 20 27 0a            JSR LINE2   ;DISPLAY THE DATA LINE.
  87 09f3 20 7c 0a            JSR LINE3   ;DISPLAY THE ARROW LINE.
  88                                      ;
  89 09f6 20 b1 09            JSR TVPOP   ;RESTORE ZERO PAGE BYTES
  90                                      ;THAT WERE SAVED ABOVE.
  91 09f9 60                  RTS         ;RETURN TO CALLER.
  92                   ;********************************************
  93                   ;
  94                   ;CLRMON
  95                   ;
  96                   ;********************************************
  97 09fa a2 00        CLRMON LDX #0      ;SET TVPTR TO COLUMN 0, ROW 0 OF
  98 09fc a0 00               LDY #0      ;SCREEN.
  99                                      ;
 100 09fe 20 1a 09            JSR TVTOXY  ;
 101                                      ;
 102 0a01 ae 19 08            LDX TVCOLS  ;WE'LL CLEAR THE FULL WIDTH OF THE
 103                                      ;
 104 0a04 a0 05               LDY #5      ;LOAD Y WITH NUMBER OF
 105                                      ;ROWS (3) TO BE CLEARED.
 106                                      ;
 107 0a06 20 f1 08            JSR CLRXY   ;CLEAR X COLUMNS, Y ROWS.
 108                                      ;
 109 0a09 60                  RTS         ;RETURN TO CALLER.
 110                   ;********************************************
 111                   ;
 112                   ;LINEL
 113                   ;
 114                   ;********************************************
 115 0a0a a2 0b        LINEL  LDX #11      ;X-COORDINATE OF LABEL "A".
 116                          ;LDY #0       ;Y-COORDINATE OF LABEL "A".
 117 0a0c a0 02               LDY #2       ;Y-COORDINATE OF LABEL "A".
 118 0a0e 20 1a 09            JSR TVTOXY   ;PLACE TVPTR AT COORDINATES GIVEN BY
 119                                       ;X,Y REGISTERS.
 120 0a11 a0 00               LDY #0       ;PUT LABELS ON THE SCREEN:
 121 0a13 8c c7 09            STY LBLCOL   ;INITIALIZE LABEL COLUMN COUNTER.
 122 0a16 b9 c8 09     LBLOOP LDA LABELS,Y ;GET A CHARACTER AND
 123 0a19 20 5a 09            JSR VUCHAR   ;PUT ITS GRAPHIC ON THE SCREEN.
 124 0a1c ee c7 09            INC LBLCOL   ;PREPARE FOR NEXT CHARACTER.
 125 0a1f ac c7 09            LDY LBLCOL   ;USE LABEL COLUMN AS AN INDEX.
 126 0a22 c0 0a               CPY #10      ;DONE LAST CHARACTER?
 127 0a24 d0 f0               BNE LBLOOP   ;IF NOT, DO NEXT ONE.
 128 0a26 60                  RTS          ;RETURN TO CALLER.
 129                   ;********************************************
 130                   ;
 131                   ;LINE2
 132                   ;
 133                   ;********************************************
 134 0a27 a2 00        LINE2  LDX #0       ;LOAD X REGISTER WITH X-COORDINATE FOR
 135                                       ;START OF DATA LINE.
 136                          ;LDY #1       ;LOAD Y REGISTER WITH Y-COORDINATE FOR
 137 0a29 a0 03               LDY #3       ;LOAD Y REGISTER WITH Y-COORDINATE FOR
 138                                       ;DATA LINE.
 139 0a2b 20 1a 09            JSR TVTOXY   ;SET TVPTR TO POINT TO THE START OF THE
 140                                       ;DATA LINE.
 141 0a2e ad c6 09            LDA SELECT+1 ;DISPLAY HIGH BYTE OF THE
 142 0a31 20 81 09            JSR VUBYTE   ;CURRENTLY SELECTED ADDRESS.
 143 0a34 ad c5 09            LDA SELECT   ;DISPLAY LOW BYTE OF THE
 144 0a37 20 81 09            JSR VUBYTE   ;CURRENTLY SELECTED ADDRESS.;
 145 0a3a 20 5d 09            JSR TVSKIP   ;SKIP ONE SPACE AFTER ADDRESS FIELD.
 146 0a3d 20 5f 0a            JSR GETSL    ;LOOK UP VALUE OF THE CURRENTLY SELECTED
 147                                       ;BYTE.
 148 0a40 48                  PHA          ;SAVE IT.
 149 0a41 20 81 09            JSR VUBYTE   ;DISPLAY IT, IN HEXADECIMAL FORMAT, IN
 150                                       ;FIELD 1.
 151 0a44 20 5d 09            JSR TVSKIP   ;SKIP ONE SPACE AFTER FIELD 1.
 152 0a47 68                  PLA          ;RESTORE VALUE OF CURRENTLY SELECTED BYTE.
 153 0a48 20 5a 09            JSR VUCHAR   ;DISPLAY THAT BYTE, IN GRAPHIC
 154                                       ;FORM, IN FIELD 2.
 155 0a4b 20 5d 09            JSR TVSKIP   ;SKIP ONE SPACE AFTER FIELD 2.
 156                          
 157 0a4e a2 00               LDX #0       ;DISPLAY 6502 REGISTER IMAGES IN FIELDS 4
 158                                       ;THRU 7:
 159 0a50 bd c1 09     VUREGS LDA REGS,X   ;LOOK UP THE REGISTER IMAGE.
 160 0a53 20 81 09            JSR VUBYTE   ;DISPLAY IT IN HEXADECIMAL FORMAT.
 161 0a56 20 5d 09            JSR TVSKIP   ;SKIP ONE SPACE AFTER HEXADECIMAL FIELD.
 162 0a59 e8                  INX          ;GET READY FOR NEXT REGISTER...
 163 0a5a e0 04               CPX #4       ;DONE 4 REGISTERS YET?;
 164 0a5c d0 f2               BNE VUREGS   ;IF NOT, DO NEXT ONE...
 165 0a5e 60                  RTS          ;IF ALL REGISTERS DISPLAYED, RETURN.
 166                   ;********************************************
 167                   ;
 168                   ;GET CURRENTLY SELECTED BYTE
 169                   ;
 170                   ;********************************************
 171 0a5f a5 fd        GETSL  LDA GETPTR     ;SAVE GETPTR
 172 0a61 48                  PHA            ;ON STACK AND
 173 0a62 a5 fe               LDA GETPTR+1   ;
 174 0a64 48                  PHA            ;
 175                   ;
 176 0a65 ad c5 09            LDA SELECT     ;SET GETPTR
 177 0a68 85 fd               STA GETPTR     ;EQUAL TO
 178 0a6a ad c6 09            LDA SELECT+1   ;SELECT.
 179 0a6d 85 fe               STA GETPTR+1   ;
 180                   ;
 181 0a6f a0 00               LDY #0         ;GET THE CONTENTS OF THE
 182 0a71 b1 fd               LDA (GETPTR),Y ;BYTE POINTED TO BY SELECT,
 183 0a73 a8                  TAY            ;AND SAVE IT IN Y REGISTER.
 184                   ;
 185 0a74 68                  PLA            ;RESTORE GETPTR
 186 0a75 85 fd               STA GETPTR     ;FROM STACK
 187 0a77 68                  PLA
 188 0a78 86 fe               STX GETPTR+1   ;AND FROM X REGISTER.
 189                                         ;
 190 0a7a 98                  TYA            ;RESTORE CONTENTS OF CURRENT BYTE FROM
 191                                         ;TEMPORARY STORAGE IN Y TO A.
 192 0a7b 60                  RTS            ;RETURN WITH CONTENTS OF CURRENTLY
 193                                         ;SELECTED BYTE IN ACCUMULATOR AND WITH
 194                                         ;THE ZERO PAGE PRESERVED.
 195                   ;********************************************
 196                   ;
 197                   ;LINE3
 198                   ;
 199                   ;********************************************
 200 0a7c ac c0 09     LINE3  LDY FIELD     ;LOOK UP CURRENT FIELD.
 201 0a7f 38                  SEC           ;IF IT IS OUT OF BOUNDS,;
 202 0a80 c0 07               CPY #7        ;SET IT TO
 203 0a82 90 05               BCC FLDOK     ;DEFAULT FIELD
 204 0a84 a0 00               LDY #0        ;(THE ADDRESS FIELD).
 205 0a86 8c c0 09            STY FIELD     ;
 206 0a89 b9 d2 09     FLDOK  LDA FIELDS,Y  ;LOOK UP COLUMN NUMBER FOR CURRENT
 207                                        ;FIELD.
 208 0a8c aa                  TAX           ;THAT WILL BE THE ARROW'S
 209                                        ;X-COORDINATE.
 210                          ;LDY #2        ;SET ARROW'S Y-COORDINATE.
 211 0a8d a0 04               LDY #4        ;SET ARROW'S Y-COORDINATE.
 212 0a8f 20 1a 09            JSR TVTOXY    ;MAKE TVPTR POINT TO ARROW
 213                                        ;LOCATION.
 214 0a92 ad 1d 08            LDA ARROW     ;PLACE AN UP-ARROW IN
 215 0a95 20 5a 09            JSR VUCHAR    ;THAT LOCATION.
 216 0a98 60                  RTS           ;RETURN TO CALLER.
 217                   ;********************************************
 218                   ;
 219                   ;LDREG
 220                   ;
 221                   ;********************************************
 222 0a99 08           LDREG  PHP           ;WHEN SUBROUTINE RETURNS,
 223 0a9a 8d c1 09            STA REGA      ;SAVE REGISTER VALUES IN REGISTER
 224 0a9d 8e c2 09            STX REGX      ;IMAGES.
 225 0aa0 8c c3 09            STY REGY      ;
 226 0aa3 68                  PLA           ;
 227 0aa4 8d c4 09            STA REGP      ;
 228 0aa7 60                  RTS           ;THEN RETURN TO CALLER.
 229                   ;********************************************
 230                   ;APPENDIX C3: ASSEMBLER LISTING OF
 231                   ;THE VISIBLE MONITOR
 232                   ;UPDATE SUBROUTINE
 233                   ;SEE CHAPTER 6 OF TOP-DOWN ASSEMBLY-LANGUAGE
 234                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
 235                   ;BY KEN SKIER
 236                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
 237                   ;LEXINGTON, MASSACHUSETTS
 238                   ;********************************************
 239                   ;
 240                   ;GETKEY
 241                   ;
 242                   ;********************************************
 243 0aa8 6c 1e 08     GETKEY JMP (ROMKEY) ;JSR GETKEY CALLS THE
 244                                       ;COMMODORE KEYBOARD INPUT
 245                                       ;ROUTINE INDIRECTLY.
 246                   ;********************************************
 247                   ;
 248                   ;UPDATE
 249                   ;
 250                   ; RIGHT ARROW MOVE POINTER RIGHT
 251                   ; LEFT ARROW  MOVE POINTER LEFT
 252                   ; SPACE BAR   INCREMENT SELECTED ADDRESS
 253                   ; RETURN      DECREMENT SELECTED ADDRESS
 254                   ; GO          CALL CODE AT SELECTED ADDRESS
 255                   ;
 256                   ;********************************************
 257 0aab 20 a8 0a     UPDATE JSR GETKEY   ;GET A CHARACTER FROM THE KEYBOARD.
 258                                       ;
 259 0aae c9 1d        IFGRTR CMP #$1D     ;IS IT THE RIGHT-ARROW KEY?
 260 0ab0 d0 10               BNE IFLFT    ;IF NOT, PERFORM TEXT TEST.
 261                                       ;
 262 0ab2 ee c0 09     NEXTF  INC FIELD    ;IF SO, SELECT THE NEXT FIELD.
 263 0ab5 ad c0 09            LDA FIELD    ;IF ARROW WAS AT THE RIGHT-MOST FIELD,
 264 0ab8 c9 07               CMP #7       ;PLACE IT UNDERNEATH THE LEFT-MOST
 265 0aba d0 05               BNE UPEX1    ;FIELD.
 266 0abc a9 00               LDA #0       ;
 267 0abe 8d c0 09            STA FIELD    ;
 268 0ac1 60           UPEX1  RTS          ;THEN RETURN.
 269                                       ;
 270 0ac2 c9 9d        IFLFT  CMP #$9D     ;IS IT THE LEFT-ARROW KEY?
 271 0ac4 d0 0b               BNE IFSP     ;IF NOT, PERFORM NEXT TEST.
 272                                       ;
 273 0ac6 ce c0 09     PREVF  DEC FIELD    ;IF SO, SELECT PREVIOUS FIELD:
 274 0ac9 10 05               BPL UPEX2    ;THE FIELD TO THE LEFT OF THE
 275 0acb a9 06               LDA #6       ;CURRENT FIELD. IF ARROW WAS AT
 276 0acd 8d c0 09            STA FIELD    ;LEFT-MOST FIELD, PLACE IT UNDER
 277                                       ;RIGHT-MOST FIELD.
 278 0ad0 60           UPEX2  RTS          ;THEN RETURN.
 279                                       ;
 280 0ad1 c9 20        IFSP   CMP #SPACE   ;IS IT THE SPACE BAR?
 281 0ad3 d0 09               BNE IFCR     ;IF NOT, PERFORM NEXT TEST.
 282                                       ;
 283 0ad5 ee c5 09     INCSL  INC SELECT   ;IF SO, STEP FORWARD THROUGH
 284 0ad8 d0 03               BNE EXIT3    ;MEMORY, BY INCREMENTING THE
 285 0ada ee c6 09            INC SELECT+1 ;POINTER THAT SPECIFIES THE DISPLAYED
 286                                       ;ADDRESS.
 287 0add 60           EXIT3  RTS          ;THEN RETURN
 288                                       ;
 289 0ade c9 0d        IFCR   CMP #CR      ;IS IT CARRIAGE RETURN?
 290 0ae0 d0 0c               BNE IFCHAR   ;IF NOT, PERFORM NEXT TEST.
 291                   ;
 292 0ae2 ad c5 09     DECSL  LDA SELECT   ;IF SO, STEP BACKWARD THROUGH
 293 0ae5 d0 03               BNE NEXT3    ;MEMORY BY DECREMENTING THE
 294 0ae7 ce c6 09            DEC SELECT+1 ;POINTER THAT SELECTS THE
 295 0aea ce c5 09     NEXT3  DEC SELECT   ;ADDRESS TO BE DISPLAYED.
 296 0aed 60                  RTS          ;THEN RETURN.
 297                                       ;
 298 0aee ae c0 09     IFCHAR LDX FIELD    ;IS ARROW UNDERNEATH THE
 299 0af1 e0 02               CPX #2       ;CHARACTER FIELD (FIELD 2)?
 300 0af3 d0 1b               BNE IFGO     ;IF NOT, PERFORM NEXT TEST.
 301                                       ;PUT THE CONTENTS OF A INTO THE CURRENTLY
 302                                       ;SELECTED ADDRESS.
 303 0af5 a8           PUTSL  TAY          ;USE Y TO HOLD THE CHARACTER WELL PUT IN
 304                                       ;THE SELECTED ADDRESS.
 305 0af6 a5 fb               LDA TVPTR    ;SAVE ZERO-PAGE POINTER TVPTR
 306 0af8 48                  PHA          ;ON STACK AND IN X BEFORE WE
 307 0af9 a6 fc               LDX TVPTR+ 1 ;USE IT TO PUT CHARACTER IN SELECTED AD-
 308                                       ;DRESS.
 309 0afb ad c5 09            LDA SELECT   ;SET TVPTR EQUAL TO SELECT,
 310 0afe 85 fb               STA TVPTR    ;SO IT POINTS TO THE
 311 0b00 ad c6 09            LDA SELECT+1 ;CURRENTLY SELECTED
 312 0b03 85 fc               STA TVPTR+ 1 ;ADDRESS.
 313 0b05 98                  TYA          ;RESTORE TO A THE CHARACTER WE'LL PUT IN
 314                                       ;THE SELECTED ADDRESS.
 315 0b06 a0 00               LDY #0       ;STORE IT IN THE
 316 0b08 91 fb               STA (TVPTR),Y ;SELECTED ADDRESS.
 317 0b0a 86 fc               STX TVPTR+1  ;RESTORE TVPTR TO
 318 0b0c 68                  PLA           ;ITS ORIGINAL VALUE.
 319 0b0d 85 fb               STA TVPTR     ;
 320 0b0f 60                  RTS           ;RETURN TO CALLER, WITH CHARACTER ORIGI-
 321                                        ;NALLY IN A NOW IN THE SELECTED ADDRESS
 322                                        ;AND WITH ZERO PAGE UNCHANGED.
 323 0b10 c9 c7        IFGO   CMP #"G"      ;IS IT 'G' FOR GO?
 324                                        ;SHIFT G
 325 0b12 d0 23               BNE IFHEX     ;IF NOT, PERFORM NEXT TEST.
 326                                        ;
 327 0b14 ac c3 09     GO     LDY REGY      ;IF SO, LOAD THE 6502 REGISTERS
 328 0b17 ae c2 09            LDX REGX      ;WITH THEIR DISPLAYED IMAGES.
 329 0b1a ad c4 09            LDA REGP      ;
 330 0b1d 48                  PHA           ;
 331 0b1e ad c1 09            LDA REGA      ;
 332 0b21 28                  PLP           ;
 333 0b22 20 34 0b            JSR CALLIT    ;CALL THE SUBROUTINE AT THE SELECTED AD-
 334                                        ;DRESS.
 335 0b25 08                  PHP           ;WHEN SUBROUTINE RETURNS,
 336 0b26 8d c1 09            STA REGA      ;SAVE REGISTER VALUES IN REGISTER
 337 0b29 8e c2 09            STX REGX      ;IMAGES.
 338 0b2c 8c c3 09            STY REGY      ;
 339 0b2f 68                  PLA           ;
 340 0b30 8d c4 09            STA REGP      ;
 341 0b33 60                  RTS           ;THEN RETURN TO CALLER.
 342                                        ;
 343 0b34 6c c5 09     CALLIT JMP (SELECT)  ;CALL THE SUBROUTINE AT THE SELECTED AD-
 344                                        ;DRESS.
 345 0b37 48           IFHEX  PHA           ;SAVE KEYBOARD CHARACTER.
 346 0b38 20 9c 0b            JSR BINARY    ;IF ACCUMULATOR HOLDS ASCII CHARACTER
 347                                        ;FOR 0 THRU 9 OR A THRU F, BINARY
 348                                        ;RETURNS THE BINARY REPRESENTATION OF THAT
 349                                        ;HEXADECIMAL DIGIT. OTHERWISE BINARY
 350                                        ;RETURNS WITH A = FF AND THE MINUS FLAG
 351                                        ;SET.
 352 0b3b 30 4a               BMI IFCLR     ;IF ACCUMULATOR DID NOT HOLD A HEXA
 353                                        ;DECIMAL CHARACTER, PERFORM NEXT TEST.
 354 0b3d a8                  TAY           ;
 355 0b3e 68                  PLA           ;
 356 0b3f 98                  TYA           ;
 357                                        ;
 358 0b40 ae c0 09            LDX FIELD    ;ROLL A INTO A HEXADECIMAL FIELD.
 359 0b43 d0 14               BNE NOTADR   ;IS ARROW UNDERNEATH THE ADDRESS FIELD
 360                                        ;(FIELD 0)? IF NOT, THE ARROW MUST BE
 361                                        ;UNDER ANOTHER HEXADECIMAL FIELD.
 362 0b45 a2 03        ADRFLD LDX #3        ;SINCE ARROW IS UNDERNEATH THE ADDRESS
 363 0b47 18           ADLOOP CLC           ;FIELD, ROLL ACCUMULATOR'S HEXADECIMAL
 364 0b48 0e c5 09            ASL SELECT    ;DIGIT INTO THE ADDRESS FIELD BY ROLLING IT
 365 0b4b 2e c6 09            ROL SELECT+1  ;INTO THE POINTER THAT SELECTS THE
 366 0b4e ca                  DEX           ;DISPLAYED ADDRESS.
 367 0b4f 10 f6               BPL ADLOOP    ;
 368 0b51 98                  TYA           ;
 369 0b52 0d c5 09            ORA SELECT    ;
 370 0b55 8d c5 09            STA SELECT    ;
 371 0b58 60                  RTS           ;THEN RETURN.
 372                                        ;
 373 0b59 e0 01        NOTADR CPX #1        ;IS ARROW UNDERNEATH FIELD 1?
 374 0b5b d0 17               BNE REGFLD    ;IF NOT, IT MUST BE UNDERNEATH A REGISTER
 375                                        ;IMAGE.
 376 0b5d 29 0f        ROLSL  AND #$0F      ;ROLL A'S 4 LSB INTO CONTENTS
 377 0b5f 48                  PHA           ;OF CURRENTLY SELECTED BYTE.
 378 0b60 20 5f 0a            JSR GETSL     ;GET THE CONTENTS OF THE SELECTED
 379 0b63 0a                  ASL A         ;ADDRESS AND SHIFT LEFT 4 TIMES.
 380 0b64 0a                  ASL A         ;
 381 0b65 0a                  ASL A         ;
 382 0b66 0a                  ASL A         ;
 383 0b67 29 f0               AND #$F0      ;
 384 0b69 8d d9 09            STA TEMP      ;SAVE IT IN A TEMDORARV VARIABLE.
 385 0b6c 68                  PLA           ;GET ORIGINAL A'S 4 LSB AND
 386 0b6d 0d d9 09            ORA TEMP      ;OR THEM WITH SHIFTED CONTENTS OF
 387                                        ;SELECTED ADDRESS.
 388 0b70 20 f5 0a            JSR PUTSL     ;STORE THE RESULT IN THE SELECTED
 389 0b73 60                  RTS           ;ADDRESS AND RETURN.
 390                                        ;
 391 0b74 ca           REGFLD DEX           ;THE ARROW MUST BE UNDERNEATH A
 392 0b75 ca                  DEX           ;REGISTER IMAGE  FIELD 3, 4, 5, OR 6.
 393 0b76 ca                  DEX           ;
 394 0b77 a0 03               LDY #3        ;
 395                                        ;
 396 0b79 18           RGLOOP CLC           ;ROLL ACCUMULATOR'S HEXADECIMAL DIGIT
 397 0b7a 1e c1 09            ASL REGS,X    ;INTO APPROPRIATE REGISTER IMAGE...
 398 0b7d 88                  DEY           ;
 399 0b7e 10 f9               BPL RGLOOP     ;
 400 0b80 1d c1 09            ORA REGS,X    ;
 401 0b83 9d c1 09            STA REGS,X    ;
 402 0b86 60                  RTS           ;...THEN RETURN.
 403                                        ;
 404 0b87 68           IFCLR  PLA
 405 0b88 c9 93               CMP #CLRKEY
 406                          
 407 0b8a d0 04               BNE NOTCLR
 408                          
 409 0b8c 20 de 08            JSR CLRTV
 410 0b8f 60                  RTS
 411                                         ;
 412 0b90 c9 d1        NOTCLR CMP #"Q"      ;IS IT Q' FOR QUIT?
 413                                        ;SHIFT Q
 414 0b92 d0 04               BNE OTHER     ;IF NOT, PERFORM NEXT TEST.
 415                                        ;
 416                                        ;USER WANTS TO RETURN TO THE
 417                                        ;CALLER OF THE VISIBLE
 418                                        ;MONITOR. SO LET'S DO THAT:
 419 0b94 68           OEXIT  PLA           ;POP UPDATE'S RETURN ADDRESS.
 420 0b95 68                  PLA           ;
 421                          
 422 0b96 28                  PLP           ;RESTORE INITIAL 6502 FLAGS.
 423                                        ;VISMON RETURN ADDRESS IS
 424                                        ;NOW ON THE STACK.
 425 0b97 60                  RTS           ;SO RETURN TO CALLER OF
 426                                        ;VISMON. IN THIS WAY,
 427                                        ;VISMON CAN BE USED BY ANY
 428                                        ;CALLER TO GET AN ADDRESS
 429                                        ;FROM THE USER.
 430                                        ;
 431                   ;OTHER  JSR DUMMY      ;REPLACE THIS CALL TO
 432                                         ;DUMMY WITH A CALL TO ANY
 433                                         ;SUBROUTINE THAT EXTENDS
 434                                         ;FUNCTIONALITY OF THE
 435                                         ;VISIBLE MONITOR.
 436                   ;       RTS            ;...RETURN
 437                                         ;
 438 0b98 20 f9 18     OTHER  JSR EXTEND    ;EXTENSION TO ADD HEX DUMP,MOVE, 
 439                                        ;TEXT EDITOR AND DISASSEMBLER
 440                                        ;FUNCTIONALITY TO THE VISIBLE MONITOR.
 441 0b9b 60                  RTS            ;...RETURN
 442                   ;********************************************
 443                   ;
 444                   ;BINARY
 445                   ;
 446                   ;********************************************
 447 0b9c 38           BINARY SEC         ;PREPARE TO SUBTRACT.
 448 0b9d e9 30               SBC #$30    ;SUBTRACT $30 FROM CHARACTER.
 449 0b9f 90 0f               BCC BAD     ;IF CHARACTER WAS ORIGINALLY LESS THAN $30,
 450                                      ;IT WAS BAD, SO RETURN $FF.
 451 0ba1 c9 0a               CMP #$0A    ;WAS CHARACTER IN THE RANGE $30 THRU
 452                                      ;$39?
 453 0ba3 90 0e               BCC GOOD    ;IF SO, IT WAS A GOOD INPUT, AND WE'VE
 454                                      ;ALREADY CONVERTED IT TO BINARY BY SUB-
 455                                      ;TRACTING $30, SO WE'LL RETURN NOW WITH
 456                                      ;THE CHARACTER'S BINARY EQUIVALENT IN THE
 457                                      ;ACCUMULATOR.
 458 0ba5 e9 07               SBC #7      ;SUBTRACT 7.
 459 0ba7 c9 10               CMP #$10    ;WAS CHARACTER ORIGINALLY IN THE RANGE
 460                                      ;$41 THRU $46?
 461 0ba9 b0 05               BCS BAD     ;IF SO, IT WAS A BAD INPUT.
 462 0bab 38                  SEC
 463 0bac c9 0a               CMP #$0A
 464 0bae b0 03               BCS GOOD
 465 0bb0 a9 ff        BAD    LDA #$FF   ;INDICATE A BAD INPUT BY RETURNING
 466 0bb2 60                  RTS        ;MINUS, WITH A HOLDING $FF.
 467 0bb3 a2 00        GOOD   LDX #0     ;INDICATE A GOOD INPUT BY RETURNING
 468 0bb5 60                  RTS        ;PLUS, WITH A HOLDING THE CHARACTER'S
 469                                     ;BINARY EQUIVALENT.
 470                   ;********************************************
 471                   ;
 472                   ;
 473                   ;
 474                   ;********************************************
 476                   
  68                   .endif
  69                   ;****************************
  70                   ; PRINT UTILITIES
  71                   ;****************************
  72                   .ifne CHAP7
  73                   .include "CHAPTER7.ASM"
   1                   ;********************************************
   2                   ;PRINT UTILITIES
   3                   ;
   4                   ;APPENDIX C4: ASSEMBLER LISTING OF
   5                   ;PRINT UTILITIES
   6                   ;SEE CHAPTER 7 OF TOP-DOWN ASSEMBLY-LANGUAGE
   7                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   8                   ;BY KEN SKIER
   9                   ;COPYRIGHT <C> 1984 BY KENNETH SKIER
  10                   ;LEXINGTON, MASSACHUSETTS
  11                   ;********************************************
  12                   ;CHARS  SEND THE CHARACTER IN THE ACCUMULATOR "X" TIMES TO ALL CURRENT-
  13                   ;       LY SELECTED OUTPUT DEVICES.
  14                   ;CRLF  CAUSE A NEW LINE ON ALL CURRENTLY SELECTED DEVICES.
  15                   ;CRLFS CAUSE ''X" NEW LINES ON ALL CURRENTLY SELECTED DEVICES.
  16                   ;PRBYT PRINT THE BYTE IN THE ACCUMULATOR, IN HEXADECIMAL REPRESENTA
  17                   ;       TION.
  18                   ;PRCHR PRINT THE CHARACTER IN THE ACCUMULATOR ON ALL CURRENTLY SELECTED
  19                   ;       DEVICES.
  20                   ;PRMSG PRINT THE MESSAGE POINTED TO BY A ZERO-PAGE POINTER SPECIFIED
  21                   ;       BY X.
  22                   ;PRINTX PRINT THE MESSAGE FOLLOWING THE CALL TO "PRINTX".
  23                   ;SPACEO SEND A SPACE TO ALL CURRENTLY SELECTED OUTPUT DEVICES.
  24                   ;SPACES SEND "X" SPACES TO ALL CURRENTLY SELECTED OUTPUT DEVICES.
  25                   ;********************************************
  26                   ;
  27                   ;DEVICE FLAGS
  28                   ;
  29                   ;********************************************
  30                   OFF = 0          ;WHEN A DEVICE FLAG = ZERO, THAT DEVICE
  31                                    ;IS NOT SELECTED.
  32                   ON = $FF         ;WHEN A DEVICE FLAG = $FF, THAT DEVICE IS
  33                                    ;SELECTED.
  34 0bb6 ff           TVT .BYTE ON     ;THIS FLAG IS ZERO IF TVT IS NOT SELECTED;
  35                                    ;NONZERO OTHERWISE. INITIALLY, THE TVT IS
  36                                    ;SELECTED.
  37 0bb7 00           PRINTR .BYTE OFF ;THIS FLAG IS ZERO IF THE PRINTR IS NOT
  38                                    ;SELECTED; NONZERO OTHERWISE. INITIALLY,
  39                                    ;THE PRINTER IS NOT SELECTED.
  40 0bb8 00           USER   .BYTE OFF ;THIS FLAG IS ZERO IF THE USER-PROVIDED
  41                                    ;OUTPUT SUBROUTINE IS NOT SELECTED;
  42                                    ;NONZERO OTHERWISE. INITIALLY, THE USERPROVIDED
  43                                    ;FUNCTION IS DESELECTED.
  44 0bb9 00           CHAR   .BYTE 0   ;THIS BYTE HOLDS THE LAST CHARACTER PASSED
  45                                    ;TO PRCHR.
  46 0bba 00           REPEAT .BYTE 0   ;THIS BYTE IS USED AS A REPEAT COUNTER BY
  47                                    ;SPACES, CHARS, AND CRLFS.
  48 0bbb 00           TEMPX  .BYTE 0    ;THIS DATA CELL IS USED TO PRESERVE THE INI-
  49                                    ;TIAL VALUE OF X.
  50 0bbc 00 00        RETURN .WORD 0   ;THIS POINTER IS USED BY PUSHSL AND
  51                                    ;POPSL TO PRESERVE THEIR RETURN AD-
  52                                    ;DRESSES.
  53                   ;********************************************
  54                   ;
  55                   ;SELECT AND DESELECT SUBROUTINES
  56                   ;
  57                   ;********************************************
  58 0bbe a9 ff        TVTON  LDA #ON    ;SELECT TVT AS AN OUTPUT DEVICE
  59 0bc0 8d b6 0b            STA TVT    ;BY SETTING THE FLAG THAT INDICATES
  60 0bc3 60                  RTS        ;THE "SELECT" STATE OF THE TVT.
  61 0bc4 a9 00        TVTOFF LDA #OFF   ;DESELECT TVT AS AN OUTPUT DEVICE
  62 0bc6 8d b6 0b            STA TVT    ;BY CLEARING THE FLAG THAT INDICATES
  63 0bc9 60                  RTS        ;THE "SELECT" STATE OF THE TVT.
  64 0bca a9 ff        PRON   LDA #ON    ;SELECT PRINTER AS AN OUTPUT DEVICE
  65 0bcc 8d b7 0b            STA PRINTR ;BY SETTING THE FLAG THAT INDICATES
  66 0bcf 60                  RTS        ;THE "SELECT" STATE OF THE PRINTER.
  67 0bd0 a9 00        PROFF  LDA #OFF   ;DESELECT PRINTER AS AN OUTPUT DEVICE
  68 0bd2 8d b7 0b            STA PRINTR ;BY CLEARING THE FLAG THAT INDICATES
  69 0bd5 60                  RTS        ;THE "SELECT" STATE OF THE PRINTER.
  70 0bd6 a9 ff        USRON  LDA #ON    ;SELECT USER-WRITTEN SUBROUTINE AS AN
  71 0bd8 8d b8 0b            STA USER   ;OUTPUT DEVICE BY SETTING THE FLAG THAT
  72 0bdb 60                  RTS        ;INDICATES THE "SELECT" STATE OF THE OUTPUT
  73                                     ;ROUTINE PROVIDED BY THE USER.
  74 0bdc a9 00        USROFF LDA #OFF   ;DESELECT USER-WRITTEN SUBROUTINE
  75 0bde 8d b8 0b            STA USER   ;AS AN OUTPUT DEVICE BY CLEARING THE FLAG
  76 0be1 60                  RTS        ;STATE OF THE OUTPUT ROUTINE PROVIDED BY
  77                                     ;THE USER
  78 0be2 20 be 0b     ALLON  JSR TVTON  ;SELECT ALL OUTPUT DEVICES BY SELECTING
  79 0be5 20 ca 0b            JSR PRON   ;EACH OUTPUT DEVICE INDIVIDUALLY.
  80 0be8 20 d6 0b            JSR USRON  ;
  81 0beb 60                  RTS        ;
  82 0bec 20 c4 0b     ALLOFF JSR TVTOFF ;DESELECT ALL OUTPUT DEVICES BY
  83 0bef 20 d0 0b            JSR PROFF  ;DESELECTING EACH OUTPUT DEVICE
  84 0bf2 20 dc 0b            JSR USROFF ;INDIVIDUALLY.
  85 0bf5 60                  RTS        ;
  86                   ;********************************************
  87                   ;
  88                   ;PRCHR
  89                   ;
  90                   ;********************************************
  91 0bf6 c9 00        PRCHR  CMP #0      ;TEST CHARACTER
  92 0bf8 f0 24               BEQ EXIT4   ;IF IT'S A NULL, RETURN WITHOUT PRINTING IT.
  93                                      ;
  94 0bfa 8d b9 0b            STA CHAR    ;SAVE THE CHARACTER.
  95                                      ;
  96 0bfd ad b6 0b            LDA TVT     ;IS TVT SELECTED?
  97 0c00 f0 06               BEQ IFPR    ;IF NOT, TEST NEXT DEVICE.
  98                                      ;
  99 0c02 ad b9 0b            LDA CHAR    ;IF SO, SEND CHARACTER INDIRECTLY TO
 100 0c05 20 1f 0c            JSR SENDL   ;SYSTEM'S TVT OUTPUT ROUTINE.
 101                                      ;
 102 0c08 ad b7 0b     IFPR   LDA PRINTR  ;IS PRINTER SELECTED?
 103 0c0b f0 06               BEQ IFUSR   ;IF NOT, TEST NEXT DEVICE.
 104                                      ;
 105 0c0d ad b9 0b            LDA CHAR    ;IF SO, SEND CHARACTER INDIRECTLY
 106 0c10 20 22 0c            JSR SEND2   ;TO SYSTEM'S PRINTER DRIVER.
 107                                      ;
 108 0c13 ad b8 0b     IFUSR  LDA USER    ;IS USER-WRITTEN OUTPUT SUBROUTINE
 109                                      ;SELECTED?
 110 0c16 f0 06                BEQ EXIT4  ;IF NOT, TEST NEXT DEVICE.
 111                                      ;
 112 0c18 ad b9 0b             LDA CHAR   ;IF SO, SEND CHARACTER INDIRECTLY
 113 0c1b 20 25 0c             JSR SEND3  ;TO USER-WRITTEN OUTPUT SUBROUTINE.
 114                                      ;
 115 0c1e 60           EXIT4   RTS        ;RETURN TO CALLER.
 116                   ;********************************************
 117                   ;
 118                   ;VECTORED SUBROUTINE CALLS
 119                   ;
 120                   ;********************************************
 121 0c1f 6c 20 08     SENDL JMP (ROMTVT)
 122 0c22 6c 22 08     SEND2 JMP (ROMPRT)
 123 0c25 6c 24 08     SEND3 JMP (USROUT)
 124                   ;********************************************
 125                   ;
 126                   ;PRINT A CARRIAGE RETURN-LINE FEED
 127                   ;
 128                   ;********************************************
 129                   ;CR = $0D ;ASCII CARRIAGE RETURN CHARACTER.
 130                   ;LF = $0A ;ASCII LINE FEED CHARACTER.
 131                   ;
 132 0c28 a9 0d        CRLF  LDA #CR     ;SEND A CARRIAGE RETURN AND A
 133 0c2a 20 f6 0b           JSR PRCHR  ;LINE FEED TO THE CURRENTLY SELECTED
 134 0c2d a9 0a              LDA #LF     ;DEVICE(S).
 135 0c2f 20 f6 0b           JSR PRCHR  ;
 136 0c32 60                 RTS         ;RETURN.
 137                   ;********************************************
 138                   ;
 139                   ;PRINT A SPACE
 140                   ;
 141                   ;********************************************
 142 0c33 a9 20        SPACEO LDA #$20    ;LOAD ACCUMULATOR WITH ASCII SPACE.
 143 0c35 20 f6 0b            JSR PRCHR  ;PRINT IT TO ALL CURRENTLY SELECTED OUTPUT
 144                                      ;DEVICES.
 145 0c38 60                  RTS         ;RETURN.
 146                   ;********************************************
 147                   ;
 148                   ;PRINT A BYTE
 149                   ;
 150                   ;********************************************
 151 0c39 48           PRBYT  PHA         ;SAVE BYTE.
 152 0c3a 4a                  LSR A       ;DETERMINE ASCII FOR THE 4 MSB (MOST-
 153                                      ;SIGNIFICANT BITS) IN THE
 154 0c3b 4a                  LSR A       ;BYTE:
 155 0c3c 4a                  LSR A       ;
 156 0c3d 4a                  LSR A       ;
 157 0c3e 20 94 09            JSR ASCII   ;
 158 0c41 20 f6 0b            JSR PRCHR  ;PRINT THAT ASCII CHARACTER TO THE CURRENT
 159                                      ;DEVICE(S).
 160 0c44 68                  PLA         ;DETERMINE ASCII FOR THE 4 LSB (LEAST-
 161                                      ;SIGNIFICANT BITS) IN THE
 162 0c45 20 94 09            JSR ASCII   ;BYTE THAT WAS PASSED TO THIS SUBROUTINE.
 163 0c48 20 f6 0b            JSR PRCHR  ;PRINT THAT ASCII CHARACTER TO THE CURRENT
 164                                      ;DEVICE(S).
 165 0c4b 60                  RTS         ;RETURN TO CALLER.
 166                   ;********************************************
 167                   ;
 168                   ;PRINT X SPACES.INT X CHARACTERS
 169                   ;
 170                   ;********************************************
 171 0c4c a9 20        SPACES LDA #$20    ;LOAD ACCUMULATOR WITH ASCII SPACE.
 172 0c4e 8e ba 0b     CHARS  STX REPEAT  ;INITIALIZE THE REPEAT COUNTER.
 173 0c51 48           RPLOOP PHA         ;SAVE CHARACTER TO BE REPEATED.
 174 0c52 ae ba 0b            LDX REPEAT  ;HAS REPEAT COUNTER TIMED OUT YET?
 175 0c55 f0 0a               BEQ RPTEND  ;IF SO, EXIT. IF NOT,
 176 0c57 ce ba 0b            DEC REPEAT  ;DECREMENT REPEAT COUNTER.
 177 0c5a 20 f6 0b            JSR PRCHR  ;PRINT CHARACTER TO ALL CURRENTLY SELECTED
 178                                      ;OUTPUT DEVICES.
 179 0c5d 68                  PLA
 180 0c5e 18                  CLC         ;LOOP BACK TO REPEAT
 181 0c5f 90 f0               BCC RPLOOP  ;CHARACTER, IF NECESSARY.
 182 0c61 68           RPTEND PLA         ;CLEAN UP STACK.
 183 0c62 60                  RTS         ;RETURN TO CALLER.
 184                   ;********************************************
 185                   ;
 186                   ;PRINT X NEWLINES
 187                   ;
 188                   ;********************************************
 189 0c63 8e ba 0b     CRLFS  STX REPEAT  ;INITIALIZE REPEAT COUNTER.
 190 0c66 ae ba 0b     CRLOOP LDX REPEAT  ;EXIT IF REPEAT COUNTER HAS TIMED OUT.
 191 0c69 f0 09               BEQ ENDCR  ;
 192 0c6b ce ba 0b            DEC REPEAT  ;DECREMENT REPEAT COUNTER.
 193 0c6e 20 28 0c            JSR CRLF   ;PRINT A CARRIAGE RETURN AND LINE FEED.
 194 0c71 18                  CLC         ;LOOP BACK TO SEE IF DONE YET.
 195 0c72 90 f2               BCC CRLOOP  ;
 196 0c74 60           ENDCR RTS         ;IF DONE, RETURN TO CALLER.
 197                   ;********************************************
 198                   ;
 199                   ;PRINT A MESSAGE
 200                   ;
 201                   ;********************************************
 202 0c75 8e bb 0b     PRMSG STX TEMPX    ;SAVE X REGISTER, WHICH SPECIFIES MESSAGE
 203                                      ;POINTER.
 204 0c78 b5 01               LDA 1,X     ;SAVE MESSAGE POINTER.
 205 0c7a 48                  PHA         ;
 206 0c7b b5 00               LDA 0,X     ;
 207 0c7d 48                  PHA         ;
 208 0c7e ae bb 0b     LOOP4  LDX TEMPX  ;RESTORE ORIGINAL VALUE OF X, SO IT POINTS
 209                                      ;TO MESSAGE POINTER.
 210 0c81 a1 00               LDA (0,X)   ;GET NEXT CHARACTER FROM MESSAGE.
 211 0c83 c9 ff               CMP #ETX    ;IS IT THE END OF MESSAGE INDICATOR?
 212 0c85 f0 0c               BEQ MSGEND  ;IF SO, HANDLE THE END OF THE MESSAGE...
 213 0c87 f6 00               INC 0,X     ;IF NOT, INCREMENT THE MESSAGE POINTER
 214 0c89 d0 02               BNE NEXT4   ;SO IT POINTS TO THE NEXT
 215 0c8b f6 01               INC 1,X     ;CHARACTER IN THE MESSAGE.
 216 0c8d 20 f6 0b     NEXT4  JSR PRCHR  ;SEND THE CHARACTER TO ALL CURRENTLY
 217                                      ;SELECTED OUTPUT DEVICES.
 218 0c90 18                  CLC         ;GET NEXT CHARACTER
 219 0c91 90 eb               BCC LOOP4   ;FROM MESSAGE.
 220 0c93 68           MSGEND PLA         ;RESTORE MESSAGE POINTER.
 221 0c94 95 00               STA 0,X     ;
 222 0c96 68                  PLA         ;
 223 0c97 95 01               STA 1,X     ;
 224 0c99 60                  RTS         ;RETURN TO CALLER, WITH MSGPTR PRE-
 225                                      ;SERVED.
 226                   ;********************************************
 227                   ;
 228                   ;
 229                   ;
 230                   ;********************************************
 231 0c9a 68           PRINTX PLA          ;PULL RETURN ADDRESS FROM
 232 0c9b aa                  TAX          ;STACK AND SAVE IT IN X AND
 233 0c9c 68                  PLA          ;REGISTERS X AND Y.
 234 0c9d a8                  TAY          ;Y REGISTERS.
 235                   ;
 236 0c9e 20 c8 0c            JSR PUSHSL   ;SAVE THE SELECT POINTER.
 237 0ca1 8e c5 09            STX SELECT   ;SET SELECT EQUAL TO
 238 0ca4 8c c6 09            STY SELECT+1 ;RETURN ADDRESS.
 239                   ;
 240 0ca7 20 d5 0a            JSR INCSL    ;INCREMENT SELECT POINTER SO IT POINTS
 241                                       ;TO TEX CHARACTER.
 242                   ;
 243 0caa 20 d5 0a     NEXTCH JSR INCSL    ;INCREMENT SELECT POINTER SO IT POINTS TO
 244                                       ;THE NEXT CHARACTER IN THE MESSAGE.
 245 0cad 20 5f 0a            JSR GETSL    ;GET CHARACTER.
 246 0cb0 c9 ff               CMP #ETX     ;IS IT END OF MESSAGE INDICATOR?
 247 0cb2 f0 06               BEQ ENDIT    ;IF SO, ADJUST RETURN ADDRESS AND RETURN.
 248 0cb4 20 f6 0b            JSR PRCHR    ;IF NOT, PRINT CHARACTER.
 249 0cb7 18                  CLC          ;LOOP BACK FOR NEXT
 250 0cb8 90 f0               BCC NEXTCH   ;CHARACTER...
 251                   ;
 252 0cba ae c5 09     ENDIT  LDX SELECT   ;
 253 0cbd ac c6 09            LDY SELECT+1 ;
 254                   ;
 255 0cc0 20 e1 0c            JSR POPSL    ;RESTORE SELECT POINTER TO ITS ORIGINAL
 256                                       ;VALUE.
 257 0cc3 98                  TYA          ;PUSH ADDRESS
 258 0cc4 48                  PHA          ;OF ETX
 259 0cc5 8a                  TXA          ;ONTO THE STACK.
 260 0cc6 48                  PHA
 261 0cc7 60                  RTS          ;RETURN (TO BYTE IMMEDIATELY FOLLOWING
 262                                       ;ETX).
 263                   ;********************************************
 264                   ;
 265                   ;SAVE SELECT POINTER
 266                   ;(PRESERVING X,Y, AND THE ZERO PAGE)
 267                   ;
 268                   ;********************************************
 269 0cc8 68           PUSHSL PLA          ;PULL RETURN ADDRESS FROM STACK AND
 270 0cc9 8d bc 0b            STA RETURN   ;STORE IT TEMPORARILY IN RETURN.
 271 0ccc 68                  PLA          ;
 272 0ccd 8d bd 0b            STA RETURN+1 ;
 273                                       ;
 274 0cd0 ad c6 09            LDA SELECT+1 ;PUSH SELECT POINTER ONTO STACK.
 275 0cd3 48                  PHA          ;
 276 0cd4 ad c5 09            LDA SELECT   ;
 277 0cd7 48                  PHA          ;
 278                                       ;
 279 0cd8 ad bd 0b            LDA RETURN+1 ;PUSH RETURN ADDRESS BACK ONTO STACK.
 280 0cdb 48                  PHA          ;
 281 0cdc ad bc 0b            LDA RETURN   ;
 282 0cdf 48                  PHA          ;
 283                                       ;
 284 0ce0 60                  RTS          ;RETURN TO CALLER. (CALLER WILL FIND SELECT
 285                                       ;POINTER ON TOP OF THE STACK.)
 286                   ;********************************************
 287                   ;
 288                   ;RESTORE SELECT POINTER
 289                   ;(PRESERVING X,Y, AND THE ZERO PAGE)
 290                   ;
 291                   ;********************************************
 292 0ce1 68           POPSL  PLA          ;SAVE RETURN ADDRESS TEMPORARILY.
 293 0ce2 8d bc 0b            STA RETURN   ;
 294 0ce5 68                  PLA          ;
 295 0ce6 8d bd 0b            STA RETURN+1 ;
 296                                       ;
 297 0ce9 68                  PLA          ;RESTORE SELECT POINTER FROM STACK.
 298 0cea 8d c5 09            STA SELECT   ;
 299 0ced 68                  PLA          ;
 300 0cee 8d c6 09            STA SELECT+1 ;
 301                                       ;
 302 0cf1 ad bd 0b            LDA RETURN+1 ;PLACE RETURN ADDRESS BACK ON STACK.
 303 0cf4 48                  PHA          ;
 304 0cf5 ad bc 0b            LDA RETURN   ;
 305 0cf8 48                  PHA          ;
 306                                       ;
 307 0cf9 60                  RTS          ;RETURN TO CALLER.
 308                   ;********************************************
 309                   ;
 310                   ;
 311                   ;
 312                   ;********************************************
 314                   
  74                   .endif
  75                   ;****************************
  76                   ; TWO HEX DUMP TOOLS
  77                   ;****************************
  78                   .ifne CHAP8
  79                   .include "CHAPTER8.ASM"
   1                   ;********************************************
   2                   ;TWO HEX DUMP TOOLS
   3                   ;
   4                   ;APPENDIX C5: ASSEMBLER LISTING OF
   5                   ;TWO HEXDUMP TOOLS
   6                   ;SEE CHAPTER 8 OF TOP-DOWN ASSEMBLY LANGUAGE
   7                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   8                   ;KEN SKIER
   9                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
  10                   ;LEXINGTON, MASSACHUSETTS
  11                   ;********************************************
  12                   ;
  13                   ;********************************************
  14                   ;
  15                   ;VARIABLES
  16                   ;
  17                   ;********************************************
  18 0cfa 00           COUNTR .BYTE 0 ;THIS BYTE COUNTS THE NUMBER OF LINES
  19                                  ;DUMPED BY TVDUMP.
  20 0cfb 07           MASK   .BYTE 7 ;FOR OUTPUT A (SUITABLE FOR
  21                                  ;C-64). USE ".BYTE 3" FOR
  22                                  ;OUTPUT B (SUITABLE FOR
  23                                  ;VIC-20).
  24 0cfc 00           COLUMN .BYTE 0 ;THIS 1-BYTE VARIABLE IS USED TO COUNT
  25                                  ;FROM 00 TO $0F.
  26                   ;********************************************
  27                   ;
  28                   ;TVDUMP
  29                   ;
  30                   ;********************************************
  31                   TVDUMP =*
  32 0cfd 20 be 0b            JSR TVTON   ;SELECT TVT AS OUTPUT DEVICE.
  33                                      ;
  34 0d00 20 83 0f            JSR HEADSN  ;OUTPUT HEXDUMP HEADER.
  35                                      ;   
  36 0d03 a9 04               LDA #4      ;SET COUNTR TO NUMBER OF
  37 0d05 8d fa 0c            STA COUNTR  ;LINES TO BE DUMPED.
  38                                      ;
  39 0d08 ad c5 09            LDA SELECT  ;SET SELECT TO BEGINNING OF
  40 0d0b 29 f0               AND #$F0    ;A HEX LINE (16 BYTES) BY
  41 0d0d 8d c5 09            STA SELECT  ;ZEROING 4 LSB IN SELECT.
  42                                      ;
  43 0d10 20 44 0d     DUMPLN JSR PRADR   ;PRINT THE SELECTED ADDRESS.
  44 0d13 20 33 0c            JSR SPACEO   ;PPRINT A SPACE ON THE SCREEN.
  45                                      ;
  46 0d16 20 33 0c     DMPBYT JSR SPACEO   ;PRINT A SPACE ON THE SCREEN.
  47 0d19 20 3d 0d            JSR DUMPSL  ;DUMP SELECTED BYTE.
  48 0d1c 20 d5 0a            JSR INCSL   ;SELECT NEXT ADDRESS BY INCREMENTING
  49                                      ;SELECT NEXT BYTE.
  50                   ;
  51 0d1f ad c5 09            LDA SELECT  ;SELECT NEXT BYTE.
  52 0d22 2d fb 0c            AND MASK    ;SELECT NEXT BYTE.
  53                                      ;0, FOR OUTPUT A, OR 2 LSB 0,
  54                                      ;FOR OUTPUT B?)
  55                                      ;
  56 0d25 d0 ef               BNE DMPBYT  ;IF NOT, DUMP NEXT BYTE...
  57 0d27 20 28 0c            JSR CRLF    ;IF SO, ADVANCE TO A NEW LINE
  58                                      ;ON SCREEN.
  59                                      ;
  60 0d2a ad c5 09            LDA SELECT  ;DOES THIS ADDRESS MARK THE
  61 0d2d 29 0f               AND #$0F    ;BEGINNING OF A NEW HEX LINE?
  62                                      ;(ARE 4 LSB 0?)
  63                                      ;
  64 0d2f d0 03               BNE IFDONE
  65 0d31 20 28 0c            JSR CRLF    ;IF SO, ADVANCE TO A NEW
  66                                      ;LINE ON SCREEN.
  67                                      ;
  68 0d34 ce fa 0c     IFDONE DEC COUNTR  ;DUMPED LAST LINE YET?
  69 0d37 d0 d7               BNE DUMPLN  ;IF NOT, DUMP NEXT LINE.
  70                                      ;
  71 0d39 20 c4 0b            JSR TVTOFF  ;DE-SELECT TVT AS OUTPUT
  72                                      ;DEVICE.
  73 0d3c 60                  RTS         ;RETURN TO CALLER.
  74                   ;********************************************
  75                   ;
  76                   ;DUMP CURRENTLY SELECTED BYTE
  77                   ;
  78                   ;********************************************
  79 0d3d 20 5f 0a     DUMPSL JSR GETSL   ;GET CURRENTLY SELECTED BYTE.
  80 0d40 20 39 0c            JSR PRBYT   ;PRINT IT IN HEXADECIMAL FORMAT.
  81 0d43 60                  RTS         ;RETURN TO CALLER.
  82                   ;********************************************
  83                   ;
  84                   ;PRINT ADDRESS
  85                   ;
  86                   ;********************************************
  87 0d44 ad c6 09     PRADR  LDA SELECT+1 ;GET THE HIGH BYTE OF SELECT...
  88 0d47 20 39 0c            JSR PRBYT    ;...AND PRINT IT IN HEXADECIMAL FORMAT.
  89 0d4a ad c5 09            LDA SELECT   ;GET THE LOW BYTE OF SELECT...
  90 0d4d 20 39 0c            JSR PRBYT    ;...AND PRINT IT IN HEXADECIMAL FORMAT.
  91 0d50 60                  RTS          ;THEN RETURN TO CALLER.
  92                   ;********************************************
  93                   ;
  94                   ;PRDUMP
  95                   ;
  96                   ;********************************************
  97 0d51 20 6c 0d     PRDUMP JSR TITLE   ;DISPLAY THE TITLE.
  98                          ;JSR SETADS  ;LET USER SET START ADDRESS AND END AD-
  99                                      ;DRESS OF MEMORY TO BE DUMPED.
 100                                      ;(SETADS RETURNS WITH SELECT=EA,
 101                                      ;THE END ADDRESS.)
 102 0d54 20 8c 0d            JSR SETADT  ;TEST CODE
 103                                      ;
 104 0d57 20 25 10            JSR GOTOSA  ;SET SELECT = SA, THE STARTING ADDRESS.
 105 0d5a 20 ca 0b            JSR PRON    ;SELECT PRINTER AS A OUTPUT DEVICE. (OTHER
 106                                      ;SELECTED DEVICES WILL ECHO THE DUMP.)
 107 0d5d 20 f2 0e            JSR HEADER  ;OUTPUT HEXDUMP HEADER.
 108 0d60 20 c7 0f     HELOOP JSR PRLINE  ;DUMP ONE LINE.
 109 0d63 10 fb               BPL HELOOP  ;DUMPED LAST LINE? IF NOT,
 110                                      ;DUMP NEXT LINE.
 111                                      ;
 112 0d65 20 28 0c            JSR CRLF    ;IF SO, GO TO A NEW LINE.
 113                                      ;
 114 0d68 20 d0 0b            JSR PROFF   ;DE-SELECT PRINTER FOR OUTPUT.
 115                                      ;
 116 0d6b 60                  RTS         ;RETURN TO CALLER.
 117                   ;********************************************
 118                   ;
 119                   ;PRINT THE HEXDUMP TITLE ON SCREEN
 120                   ;
 121                   ;********************************************
 122 0d6c 20 be 0b     TITLE  JSR TVTON   ;SELECT SCREEN FOR OUTPUT.
 123 0d6f 20 d0 0b            JSR PROFF   ;DE-SELECT PRINTER.
 124 0d72 20 9a 0c            JSR PRINTX  ;OUTPUT THE FOLLOWING TEXTs
 125 0d75 7f                  .BYTE TEX   ;TEXT STRING MUST START
 126                                      ;WITH A START OF TEXT CHAR.
 127 0d76 0d                  .BYTE CR
 128 0d77 50 52 49 4e         .TEXT "PRINTING HEXDUMP"
     0d7b 54 49 4e 47 
     0d7f 20 48 45 58 
     0d83 44 55 4d 50 
 129 0d87 0d 0a 0a            .BYTE CR,LF,LF 
 130 0d8a ff                  .BYTE ETX    ;TEXT STRING MUST END WITH
 131                                       ;AN END OF TEXT CHARACTER.
 132 0d8b 60                  RTS          ;RETURN TO CALLER.
 133                   ;********************************************
 134                   ;
 135                   ;SET STARTING ADDRESS, ENDING ADDRESS
 136                   ;TEST MODE
 137                   ;
 138                   ;********************************************
 139 0d8c 20 be 0b     SETADT JSR TVTON    ;SELECT TVT AS AN OUTPUT DEVICE. ALL
 140                                       ;OTHER SELECTED OUTPUT DEVICES WILL ECHO
 141                                       ;THE SCREEN OUTPUT.
 142 0d8f 20 9a 0c            JSR PRINTX   ;PUT PROMPT ON THE SCREEN:
 143 0d92 7f                  .BYTE TEX    ;
 144 0d93 0d 0a 0a            .BYTE CR,LF,LF                ;
 145 0d96 53 45 54 20         .TEXT "SET STARTING ADDRESS " ;
     0d9a 53 54 41 52 
     0d9e 54 49 4e 47 
     0da2 20 41 44 44 
     0da6 52 45 53 53 
     0daa 20 
 146 0dab 54 4f 20 46         .TEXT "TO FRERAM"             ;
     0daf 52 45 52 41 
     0db3 4d 
 147 0db4 0d 0a               .BYTE CR,LF                   ;
 148 0db6 ff                  .BYTE ETX                     ;
 149                          ;JSR VISMON   ;CALL THE VISIBLE MONITOR, SO USER CAN
 150                          ;             ;SPECIFY A GIVEN ADDRESS.
 151 0db7 a9 00               LDA #<FRERAM ;
 152 0db9 8d c5 09            STA SELECT   ;
 153 0dbc a9 c1               LDA #>FRERAM ;
 154 0dbe 8d c6 09            STA SELECT+1 ;
 155                                       ;
 156 0dc1 20 72 0e            JSR SAHERE   ;SET STARTING ADDRESS EQUAL TO ADDRESS SET
 157                                       ;BY THE USER.
 158 0dc4 20 9a 0c            JSR PRINTX   ;PUT PROMPT ON THE SCREEN:
 159 0dc7 7f                  .BYTE TEX
 160 0dc8 0d 0a 0a            .BYTE CR,LF,LF
 161 0dcb 53 45 54 20         .TEXT "SET ENDING ADDRESS "
     0dcf 45 4e 44 49 
     0dd3 4e 47 20 41 
     0dd7 44 44 52 45 
     0ddb 53 53 20 
 162 0dde 46 52 45 54         .TEXT "FRETOP" 
     0de2 4f 50 
 163 0de4 0d 0a               .BYTE CR,LF                   ;
 164 0de6 ff                  .BYTE ETX
 165                          ;JSR VISMON   ;CALL THE VISIBLE MONITOR, SO USER CAN
 166                          ;             ;SPECIFY A GIVEN ADDRESS.
 167 0de7 a9 ff               LDA #<FRETOP ;
 168 0de9 8d c5 09            STA SELECT   ;
 169 0dec a9 c1               LDA #>FRETOP ;
 170 0dee 8d c6 09            STA SELECT+1 ;
 171                                       ;
 172 0df1 20 65 0e            JSR EAHERE   ;
 173                                       ;
 174 0df4 60                  RTS          ;
 175                   ;********************************************
 176                   ;
 177                   ;LET USER SET STARTING ADDRESS AND
 178                   ;END ADDRESS OF A BLOCK OF MEMORY:
 179                   ;
 180                   ;********************************************
 181 0df5 4c 8c 0d     SETADS JMP SETADT   ;TEST CODE
 182 0df8 20 be 0b            JSR TVTON    ;SELECT TVT AS AN OUTPUT DEVICE. ALL
 183                                       ;OTHER SELECTED OUTPUT DEVICES WILL ECHO
 184                                       ;THE SCREEN OUTPUT.
 185 0dfb 20 9a 0c            JSR PRINTX   ;PUT PROMPT ON THE SCREEN:
 186 0dfe 7f                  .BYTE TEX    ;
 187 0dff 0d 0a 0a            .BYTE CR,LF,LF                ;
 188 0e02 53 45 54 20         .TEXT "SET STARTING ADDRESS " ;
     0e06 53 54 41 52 
     0e0a 54 49 4e 47 
     0e0e 20 41 44 44 
     0e12 52 45 53 53 
     0e16 20 
 189 0e17 41 4e 44 20         .TEXT "AND PRESS Q"           ;
     0e1b 50 52 45 53 
     0e1f 53 20 51 
 190 0e22 ff                  .BYTE ETX                     ;
 191 0e23 20 da 09            JSR VISMON   ;CALL THE VISIBLE MONITOR, SO USER CAN
 192                                       ;SPECIFY A GIVEN ADDRESS.
 193 0e26 20 72 0e            JSR SAHERE   ;SET STARTING ADDRESS EQUAL TO ADDRESS SET
 194                                       ;BY THE USER.
 195 0e29 20 9a 0c     SETEA  JSR PRINTX   ;PUT PROMPT ON THE SCREEN:
 196 0e2c 7f                  .BYTE TEX
 197 0e2d 0d 0a 0a            .BYTE CR,LF,LF
 198 0e30 53 45 54 20         .TEXT "SET ENDING ADDRESS "
     0e34 45 4e 44 49 
     0e38 4e 47 20 41 
     0e3c 44 44 52 45 
     0e40 53 53 20 
 199 0e43 41 4e 44 20         .TEXT "AND PRESS Q" 
     0e47 50 52 45 53 
     0e4b 53 20 51 
 200 0e4e ff                  .BYTE ETX
 201 0e4f 20 da 09            JSR VISMON   ;CALL THE VISIBLE MONITOR, SO USER CAN
 202                                       ;SPECIFY A GIVEN ADDRESS.
 203 0e52 38                  SEC          ;IF USER TRIED TO SET AN
 204 0e53 ad c6 09            LDA SELECT+1 ;ENDING ADDRESS LESS THAN
 205 0e56 cd 13 08            CMP SA+1     ;THE STARTING ADDRESS,
 206 0e59 90 24               BCC TOOLOW   ;MAKE USER DO IT OVER.
 207 0e5b d0 08               BNE EAHERE   ;IF SELECT IS GREATER THAN SA, SET
 208                                       ;EA=SELECT. THAT WILL MAKE EA
 209                                       ;GREATER THAN SA.
 210 0e5d ad c5 09            LDA SELECT   ;
 211 0e60 cd 12 08            CMP SA       ;
 212 0e63 90 1a               BCC TOOLOW   ;
 213 0e65 ad c6 09     EAHERE LDA SELECT+1 ;SET EA=SELECT.
 214 0e68 8d 15 08            STA EA+1     ;
 215 0e6b ad c5 09            LDA SELECT   ;
 216 0e6e 8d 14 08            STA EA       ;
 217 0e71 60                  RTS          ;... AND RETURN.
 218 0e72 ad c6 09     SAHERE LDA SELECT+1 ;SET SA=SELECT.
 219 0e75 8d 13 08            STA SA+1     ;
 220                   ;
 221 0e78 ad c5 09            LDA SELECT
 222 0e7b 8d 12 08            STA SA
 223 0e7e 60                  RTS           ;...AND RETURN.
 224 0e7f 20 9a 0c     TOOLOW JSR PRINTX    ;SINCE USER SET ENDING ADDRESS
 225 0e82 7f                  .BYTE TEX     ;TOO LOW, PRINT ERROR MESSAGE:
 226 0e83 0d 0a 0d            .BYTE CR,LF,CR
 227 0e86 45 52 52 4f         .TEXT "ERROR! "
     0e8a 52 21 20 
 228 0e8d 45 4e 44 20         .TEXT "END ADDRESS LESS "
     0e91 41 44 44 52 
     0e95 45 53 53 20 
     0e99 4c 45 53 53 
     0e9d 20 
 229 0e9e 54 48 41 4e         .TEXT "THAN START ADDRESS, "
     0ea2 20 53 54 41 
     0ea6 52 54 20 41 
     0eaa 44 44 52 45 
     0eae 53 53 2c 20 
 230 0eb2 57 48 49 43         .TEXT "WHICH IS "
     0eb6 48 20 49 53 
     0eba 20 
 231 0ebb ff                  .BYTE ETX
 232 0ebc 20 c2 0e            JSR PRSA     ;PRINT STARTING ADDRESS. ...AND LET THE USER
 233                                       ;SET
 234 0ebf 4c 29 0e            JMP SETEA    ;THE ENDING ADDRESS AGAIN.
 235                   ;********************************************
 236                   ;
 237                   ;PRINT START ADDRESS
 238                   ;
 239                   ;********************************************
 240 0ec2 a9 24        PRSA  LDA #"$"     ;PRINT A DOLLAR SIGN TO
 241 0ec4 20 f6 0b           JSR PRCHR    ;INDICATE HEXADECIMAL.
 242 0ec7 ad 13 08           LDA SA+1     ;PRINT HIGH BYTE OF STARTING ADDRESS.
 243 0eca 20 39 0c           JSR PRBYT
 244 0ecd ad 12 08           LDA SA       ;PRINT LOW BYTE OF STARTING ADDRESS.
 245 0ed0 20 39 0c           JSR PRBYT
 246 0ed3 60                 RTS          ;RETURN TO CALLER.
 247                   ;********************************************
 248                   ;
 249                   ;PPRINT END ADDRESS
 250                   ;
 251                   ;********************************************
 252 0ed4 a9 24        PREA  LDA #"$"     ;PRINT A DOLLAR SIGN TO
 253 0ed6 20 f6 0b           JSR PRCHR    ;INDICATE HEXADECIMAL.
 254 0ed9 ad 15 08           LDA EA+1     ;PRINT HIGH BYTE OF ENDING ADDRESS.
 255 0edc 20 39 0c           JSR PRBYT
 256 0edf ad 14 08           LDA EA       ;PRINT LOW BYTE OF ENDING ADDRESS.
 257 0ee2 20 39 0c           JSR PRBYT
 258 0ee5 60                 RTS          ;RETURN TO CALLER.
 259                   ;********************************************
 260                   ;
 261                   ;PRINT RANGE OF ADDRESSES
 262                   ;
 263                   ;********************************************
 264 0ee6 20 c2 0e     RANGE JSR PRSA     ;PRINT STARTING ADDRESS.
 265 0ee9 a9 2d              LDA #$2D     ;"" PRINT A HYPHEN.
 266 0eeb 20 f6 0b           JSR PRCHR
 267 0eee 20 d4 0e           JSR PREA     ;PRINT ENDING ADDRESS.
 268 0ef1 60                 RTS          ;RETURN TO CALLER.
 269                   ;********************************************
 270                   ;
 271                   ;PRINT HEADER
 272                   ;
 273                   ;********************************************
 274 0ef2 20 9a 0c     HEADER JSR PRINTX
 275 0ef5 7f                  .BYTE TEX
 276 0ef6 0d 0a 0a            .BYTE CR,LF,LF
 277 0ef9 44 55 4d 50         .TEXT "DUMPING "
     0efd 49 4e 47 20 
 278 0f01 0d 0a 0a            .BYTE CR,LF,LF
 279 0f04 ff                  .BYTE ETX
 280                   ;
 281 0f05 20 e6 0e            JSR RANGE
 282 0f08 20 28 0c            JSR CRLF
 283                   ;
 284 0f0b 20 9a 0c            JSR PRINTX
 285 0f0e 7f 0a 0a            .BYTE TEX,LF,LF
 286 0f11 41 44 44 52         .TEXT "ADDR   0  1  2  3  4  5  6  7  "
     0f15 20 20 20 30 
     0f19 20 20 31 20 
     0f1d 20 32 20 20 
     0f21 33 20 20 34 
     0f25 20 20 35 20 
     0f29 20 36 20 20 
     0f2d 37 20 20 
 287 0f30 38 20 20 39         .TEXT "8  9  A  B  C  D  E  F"
     0f34 20 20 41 20 
     0f38 20 42 20 20 
     0f3c 43 20 20 44 
     0f40 20 20 45 20 
     0f44 20 46 
 288 0f46 0d 0a               .BYTE CR,LF
 289 0f48 ff                  .BYTE ETX
 290                   ;
 291 0f49 60                  RTS
 292                   ;********************************************
 293                   ;
 294                   ;PRINT RANGE OF ADDRESSES
 295                   ;
 296                   ;********************************************
 297 0f4a 00 00        EADD .WORD $0000
 298 0f4c ad c5 09     RANGS LDA SELECT
 299 0f4f 8d 12 08           STA SA
 300 0f52 ad c6 09           LDA SELECT+1
 301 0f55 8d 13 08           STA SA+1
 302                   ;
 303 0f58 20 c2 0e           JSR PRSA     ;PRINT STARTING ADDRESS.
 304                   ;
 305 0f5b a9 2d              LDA #$2D     ;"" PRINT A HYPHEN.
 306 0f5d 20 f6 0b           JSR PRCHR
 307                   ;
 308 0f60 ad c5 09           LDA SELECT
 309 0f63 8d 14 08           STA EA
 310 0f66 ad c6 09           LDA SELECT+1
 311 0f69 8d 15 08           STA EA+1
 312                   ;
 313 0f6c 18                 CLC
 314 0f6d ad 14 08           LDA EA
 315 0f70 69 1f              ADC #$1F
 316 0f72 8d 14 08           STA EA
 317 0f75 90 08              BCC E0
 318 0f77 ad 15 08           LDA EA+1
 319 0f7a 69 00              ADC #$00
 320 0f7c 8d 15 08           STA EA+1
 321                   ;
 322 0f7f 20 d4 0e     E0    JSR PREA     ;PRINT ENDING ADDRESS.
 323 0f82 60                 RTS          ;RETURN TO CALLER.
 324                   ;********************************************
 325                   ;
 326                   ;PRINT HEADER
 327                   ;
 328                   ;********************************************
 329 0f83 20 9a 0c     HEADSN JSR PRINTX
 330 0f86 7f                  .BYTE TEX
 331 0f87 0d 0a 0a            .BYTE CR,LF,LF
 332 0f8a 44 55 4d 50         .TEXT "DUMPING "
     0f8e 49 4e 47 20 
 333 0f92 0d 0a 0a            .BYTE CR,LF,LF
 334 0f95 ff                  .BYTE ETX
 335                   ;
 336 0f96 20 4c 0f            JSR RANGS
 337 0f99 20 28 0c            JSR CRLF
 338                   ;
 339 0f9c 20 9a 0c            JSR PRINTX
 340 0f9f 7f                  .BYTE TEX
 341 0fa0 0d 0a 0a            .BYTE CR,LF,LF
 342 0fa3 41 44 44 52         .TEXT "ADDR   0  1  2  3  4  5  6  7  "
     0fa7 20 20 20 30 
     0fab 20 20 31 20 
     0faf 20 32 20 20 
     0fb3 33 20 20 34 
     0fb7 20 20 35 20 
     0fbb 20 36 20 20 
     0fbf 37 20 20 
 343 0fc2 0d 0a 0a            .BYTE CR,LF,LF
 344 0fc5 ff                  .BYTE ETX
 345                   ;
 346 0fc6 60                  RTS
 347                   ;********************************************
 348                   ;
 349                   ;PRLINE
 350                   ;
 351                   ;********************************************
 352 0fc7 20 28 0c     PRLINE JSR CRLF    
 353 0fca ad c5 09            LDA SELECT  ;DETERMINE STARTING COLUMN
 354 0fcd 48                  PHA         ;FOR THIS DUMP.
 355 0fce 29 0f               AND #$0F    ;
 356 0fd0 8d fc 0c            STA COLUMN  ;NOW COLUMN HOLDS NUMBER OF
 357                                      ;HEX COLUMN IN WHICH WE DUMP
 358                                      ;THE FIRST BYTE.
 359 0fd3 68                  PLA         ;SET SELECT TO BEGINNING OF
 360 0fd4 29 f0               AND #$F0    ;A HEX LINE.
 361 0fd6 8d c5 09            STA SELECT  ;
 362 0fd9 20 44 0d            JSR PRADR   ;PPRINT LINE'S START ADDRESS.
 363 0fdc a2 03               LDX #3      ;SPACE 3 IIMESTO THE
 364 0fde 20 4c 0c            JSR SPACES  ;FIRST HEX COLUMN.
 365                                      ;
 366 0fe1 ad fc 0c            LDA COLUMN  ;DO WE DUMP FROM THE FIRST
 367                                      ;HEX COLUMN?
 368 0fe4 f0 0d               BEQ COLOK   ;IF SO, WERE AT THE CORRECT
 369                                      ;COLUMN NOW.
 370                                      ;
 371 0fe6 a2 03        LOOPP  LDX #3      ;IF NOT, SPACE 3 TIMES FOR
 372 0fe8 20 4c 0c            JSR SPACES  ;EACH BYTE NOT DUMPED.
 373 0feb 20 d5 0a            JSR INCSL   ;
 374 0fee ce fc 0c            DEC COLUMN  ;
 375 0ff1 d0 f3               BNE LOOPP   ;
 376                                      ;
 377 0ff3 20 3d 0d     COLOK  JSR DUMPSL  ;DUMP SELECTED BYTE.
 378 0ff6 20 33 0c            JSR SPACEO   ;SPACE ONCE.
 379 0ff9 20 08 10            JSR NEXTSL  ;SELECT NEXT BYTE
 380                                      ;
 381 0ffc 30 09               BMI EXITP   ;MINUS MEANS WE'VE DUMPED
 382                                      ;THROUGH TO THE END ADDRESS.
 383                                      ;
 384 0ffe ad c5 09     NOTEA  LDA SELECT  ;DUMPED ENTIRE LINE?
 385 1001 29 0f               AND#$0F     ;(ARE 4 LSB OF SELECT 0?)
 386 1003 c9 00               CMP #0      ;IF SO, WE'VE DUMPED THE
 387                                      ;ENTIRE LINE. IF NOT,
 388 1005 d0 ec               BNE COLOK   ;SELECT NEXT BYTE AND DUMP IT.
 389 1007 60           EXITP  RTS         ;RETURN MINUS IF EA DUMPED...
 390                                      ;OR PLUS IF EA NOT DUMPED.
 391                   ;********************************************
 392                   ;
 393                   ;SELECT NEXT BYTE (IF < END ADDRESS)
 394                   ;
 395                   ;********************************************
 396 1008 38           NEXTSL SEC          ;
 397 1009 ad c6 09            LDA SELECT+1 ;HIGH BYTE OF SELECT LESS
 398 100c cd 15 08            CMP EA+1     ;THAN HIBH BYTE OF EA?
 399 100f 90 0b               BCC SLOK     ;IF SO, SELECT<END ADDRESS.
 400 1011 d0 0f               BNE NOINC    ;IF SELECT>EA, DON'T
 401                                       ;INCREMENT SELECT.
 402                                       ;
 403 1013 38                  SEC          ;SELECT IS IN SAME PAGE AS EA.
 404 1014 ad c5 09            LDA SELECT   ; 
 405 1017 cd 14 08            CMP EA       ; 
 406 101a b0 06               BCS NOINC    ;
 407                                       ;
 408 101c 20 d5 0a     SLOK   JSR INCSL    ;SINCE SELECT NOT GREATER THAN
 409                                       ;EA, WE MAY INCREMENT SELECT.
 410                                       ;
 411 101f a9 00               LDA #0       ;SET "INCREMENTED" RETURN
 412 1021 60                  RTS          ;CODE AND RETURN.
 413                                       ;
 414 1022 a9 ff        NOINC  LDA #$FF     ;SET "NO INCREMENT" RETURN
 415 1024 60                  RTS          ;CODE AND RETURN.
 416                   ;********************************************
 417                   ;
 418                   ;GO TO START OF BLOCK
 419                   ;
 420                   ;********************************************
 421 1025 ad 12 08     GOTOSA LDA SA       ;SET SELECT EQUAL TO SA.
 422 1028 8d c5 09            STA SELECT   ;
 423 102b ad 13 08            LDA SA+1     ;
 424 102e 8d c6 09            STA SELECT+1 ;
 425 1031 60                  RTS          ;AND RETURN.
 426                   ;********************************************
 427                   ;
 428                   ;
 429                   ;
 430                   ;********************************************
 432                   
  80                   .endif
  81                   ;****************************
  82                   ; A TABLE-DRIVEN DISASSMBLER
  83                   ;****************************
  84                   .ifne CHAP9
  85                   .include "CHAPTER9.ASM"
   1                   ;********************************************
   2                   ;A TABLE-DRIVEN DISASSMBLER
   3                   ;
   4                   ;APPENDIX C6: ASSEMBLER LISTING OF
   5                   ;TABLE-DRIVEN DISASSEMBLER
   6                   ;TOP-LEVEL AND UTILITY SUBROUTINES
   7                   ;SEE CHAPTER 9 OF TOP-DOWN ASSEMBLY LANGUAGE
   8                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   9                   ;BY KEN SKIER
  10                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
  11                   ;LEXINGTON, MASSACHUSETTS
  12                   ;
  13                   ;********************************************
  14                   
  15                   ;********************************************
  16                   ;
  17                   ;CONSTANTS
  18                   ;
  19                   ;********************************************
  20                   
  21                   ;********************************************
  22                   ;
  23                   ;VARIABLES
  24                   ;
  25                   ;********************************************
  26 1032 05           DISLNS .BYTE 5    ;NUMBER OF LINES TO BE
  27                                     ;DISASSEMBLED BY TV.DIS.
  28                                     ;
  29 1033 00           LINUM  .BYTE 0    ;DATA CELL: USED BY TV.DIS.
  30                   
  31 1034 00           LETTER .BYTE 0    ;COUNTS LETTERS PRINTED IN
  32                                     ;A MNEMONIC. USED BY MNEMON.
  33                                     ;
  34 1035 00           TEMPD  .BYTE 0    ;DATA CELL USED BY MNEMON.
  35                                     ;
  36 1036 00 00        SUBPTR .WORD 0    ;POINTER TO A SUBROUTINE.
  37                                     ;SET, USED BY MODE.X
  38                                     ;
  39 1038 00           OPBYTS .BYTE 0    ;DATA CELL: USED BY FINISH.
  40                                     ;
  41 1039 00           OPCHRS .BYTE 0    ;DATA CELL: USED BY FINISH.
  42                                     ;
  43 103a 0b           ADRCOL .BYTE 11   ;STARTING COLUMN FOR ADDRESS
  44                                     ;FIELD.
  45                   ;********************************************
  46                   ;
  47                   ;TV-DISASSEMBLER
  48                   ;
  49                   ;********************************************
  50 103b 20 be 0b     TVDIS  JSR TVTON   ;SELECT SCREEN FOR OUTPUT.
  51 103e ad 32 10            LDA DISLNS  ;INITIALIZE LINE COUNTER WITH
  52 1041 8d 33 10            STA LINUM   ;# OF LINES TO DISASSEMBLE.
  53                                      ;
  54 1044 a9 ff               LDA #$FF    ;SET END ADDRESS TO $FFFF,
  55 1046 8d 14 08            STA EA      ;SO NEXTSL WILL ALWAYS
  56 1049 8d 15 08            STA EA+1    ;INCREMENT SELECT POINTER.
  57 104c 20 28 0c            JSR CRLF    ;ADVANCE TO A NEW LINE.
  58                                      ;
  59 104f 20 aa 10     TVLOOP JSR DSLINE  ;DISASSEMBLE ONE LINE.
  60 1052 ce 33 10            DEC LINUM   ;DONE LAST LINE YET?
  61 1055 d0 f8               BNE TVLOOP  ;IF NOT, DO NEXT ONE.
  62 1057 60                  RTS         ;IF SO, RETURN.
  63                   ;********************************************
  64                   ;
  65                   ;PRINTING DISASSEMBLER
  66                   ;
  67                   ;********************************************
  68 1058 20 d0 0b     PRDIS  JSR PROFF   ;DE-SELECT PRINTER
  69 105b 20 be 0b            JSR TVTON   ;SELECT SCREEN FOR OUTPUT.
  70 105e 20 9a 0c            JSR PRINTX  ;DISPLAY TITLE.
  71 1061 7f 0d 0a            .BYTE TEX,CR,LF
  72 1064 20 50 52 49         .TEXT " PRINTING DISASSEMBLER." 
     1068 4e 54 49 4e 
     106c 47 20 44 49 
     1070 53 41 53 53 
     1074 45 4d 42 4c 
     1078 45 52 2e 
  73 107b 0d 0a ff            .BYTE CR,LF,ETX
  74                                      ;
  75 107e 20 14 15             JSR SETADI  ;TEST CODE
  76                          ;JSR SETADS  ;LET USER SET START, END
  77                                      ;ADDRESSES OF MEMORY TO BE
  78                                      ;DISASSEMBLED.
  79 1081 20 ca 0b            JSR PRON    ;SELECT PRINTER FOR OUTPUT.
  80 1084 20 9a 0c            JSR PRINTX  ;
  81 1087 7f 0d 0a           .BYTE TEX,CR,LF
  82 108a 44 49 53 41        .TEXT "DISASSEMBLING"
     108e 53 53 45 4d 
     1092 42 4c 49 4e 
     1096 47 
  83 1097 ff                 .BYTE ETX
  84                                      ;
  85 1098 20 e6 0e            JSR RANGE   ;PRINT RANGE OF MEMORY TO
  86                                      ;BE DISASSEMBLED.
  87                                      ;
  88 109b 20 25 10            JSR GOTOSA  ;MAKE SELECT POINT TO START
  89                                      ;OF BLOCK.
  90                                      ;
  91 109e 20 28 0c            JSR CRLF    ;ADVANCE TO A NEW LINE.
  92 10a1 20 aa 10     DILOOP JSR DSLINE  ;DISASSEMBLE ONE LINE.
  93 10a4 10 fb               BPL DILOOP  ;IF IT WASN'T THE LAST LINE,
  94                                      ;DISASSEMBLE THE NEXT ONE.
  95                                      ;
  96 10a6 20 d0 0b            JSR PROFF   ;DE-SELECT PRINTER FOR OUTPUT.
  97                                      ;
  98 10a9 60                  RTS         ;RETURN TO CALLER.
  99                   ;********************************************
 100                   ;
 101                   ;DISASSEMBLE ONE LINE
 102                   ;
 103                   ;********************************************
 104 10aa 20 5f 0a     DSLINE JSR GETSL   ;GET CURRENTLY-SELECTED BYTE.
 105 10ad 48                  PHA         ;SAVE IT ON STACK.
 106 10ae 20 bf 10            JSR MNEMON  ;PRINT MNEMONIC REPRESENTED
 107                                      ;BY THAT OPCODE.
 108 10b1 20 33 0c            JSR SPACEO  ;SPACE ONCE.
 109 10b4 68                  PLA         ;RESTORE OPCODE.
 110 10b5 20 dc 10            JSR OPERND  ;PRINT OPERAND REQUIRED BY
 111                                      ;THAT OPCODE.
 112 10b8 20 2e 11            JSR FINISH  ;FINISH THE LINE BY PRINTING
 113                                      ;FIELDS 3-6. FINISH LEAVES
 114                                      ;SELECT POINTING TO LAST
 115                                      ;BYTE OF INSTRUCTION.
 116                                      ;
 117 10bb 20 08 10            JSR NEXTSL  ;SELECT NEXT BYTE, IF
 118                                      ;SELECT<EA.
 119 10be 60                  RTS         ;RETURN W/RETURNCODE FROM
 120                                      ;NEXTSL. SELECT POINTS TO
 121                                      ;NEXT OPCODE, OR SELECT
 122                                      ;EQUALS EA.
 123                   ;********************************************
 124                   ;
 125                   ;PRINT MNEMONIC
 126                   ;
 127                   ;********************************************
 128 10bf a2 03        MNEMON LDX #3       ;WE'LL PRINT THREE LETTERS.
 129 10c1 8e 34 10            STX LETTER   ;
 130 10c4 aa                  TAX          ;PREPARE TO USE OPCODE AS AN
 131                                       ;INDEX.
 132                                       ;
 133 10c5 bd 14 13            LDA MCODES,X ;LOOK UP MNEMONIC CODE FOR
 134                                       ;THAT OPCODE. MCODES IS
 135                                       ;TABLE OF MNEMONIC CODES.
 136                                       ;
 137 10c8 aa                  TAX          ;PREPARE TO USE THAT MNEMONIC
 138                                       ;CODE AS AN INDEX.
 139 10c9 bd 64 12     MNLOOP LDA MNAMES,X ;GET A MNEMONIC CHARACTER.
 140                                       ;(MNAMES IS A LIST OF
 141                                       ;
 142                                       ;MNEMONIC NAMES.)
 143 10cc 8e 35 10            STX TEMPD    ;SAVE X-REGISTER, SINCE
 144                                       ;PRINTING MAY CHANGE X
 145 10cf 20 f6 0b            JSR PRCHR    ;PRINT THE MNEMONIC CHARACTER.
 146 10d2 ae 35 10            LDX TEMPD    ;RESTORE X.
 147 10d5 e8                  INX          ;ADJUST INDEX FOR NEXT LETTER.
 148 10d6 ce 34 10            DEC LETTER   ;PRINTED 3 LETTERS YET?
 149 10d9 d0 ee               BNE MNLOOP   ;IF NOT, PRINT NEXT ONE.
 150 10db 60                  RTS          ;IF SO, RETURN TO CALLER.
 151                   ;********************************************
 152                   ;
 153                   ;PRINT OPERAND
 154                   ;
 155                   ;********************************************
 156 10dc aa           OPERND TAX         ;LOOK UP ADDRESSING MODE
 157 10dd bd 14 14            LDA MODES,X ;CODE FOR THIS OPCODE.
 158                                      ;
 159 10e0 aa                  TAX         ;X NOW INDICATES ADDRESSING
 160                                      ;MODE.
 161                                      ;
 162 10e1 20 e5 10            JSR MODEX   ;HANDLE THAT ADDRESSING MODE.
 163 10e4 60                  RTS         ;RETURN TO CALLER.
 164                   ;********************************************
 165                   ;
 166                   ;HANDLE ADDRESSING MODE "X"
 167                   ;
 168                   ;********************************************
 169 10e5 bd 46 12     MODEX  LDA SUBS,X   ;GET LOW BYTE OF Xth POINTER
 170 10e8 8d 36 10            STA SUBPTR   ;IN TABLE OF SUBROUTINE
 171                                       ;POINTERS.
 172 10eb e8                  INX          ;ADJUST INDEX FOR NEXT BYTE.
 173 10ec bd 46 12            LDA SUBS,X   ;GET HIGH BYTE OF POINTER.
 174 10ef 8d 37 10            STA SUBPTR+1 ;
 175 10f2 6c 36 10            JMP (SUBPTR) ;JUMP TO SUBROUTINE SPECIFIED
 176                                       ;BY SUBROUTINE POINTER.
 177                                       ;THAT SUBROUTINE WILL RETURN
 178                                       ;TO THE CALLER OF MODE.X,
 179                                       ;NOT TO MODE.X ITSELF.
 180                   ;********************************************
 181                   ;
 182                   ;DISASSEMBLER UTILITIES
 183                   ;
 184                   ;********************************************
 185                   
 186                   ;********************************************
 187                   ;
 188                   ;PRINT ONE-BYTE OPERAND
 189                   ;
 190                   ;********************************************
 191 10f5 20 d5 0a     ONEBYT JSR INCSL   ;ADVANCE TO BYTE FOLLOWING
 192                                      ;OPCODE.
 193 10f8 20 3d 0d            JSR DUMPSL  ;DUMP THAT BYTE.
 194 10fb 60                  RTS         ;RETURN TO CALLER.
 195                   ;********************************************
 196                   ;
 197                   ;PRINT TWO-BYTE OPERAND:
 198                   ;
 199                   ;********************************************
 200 10fc 20 d5 0a     TWOBYT JSR INCSL   ;ADVANCE TO FIRST BYTE OF
 201                                      ;OPERAND.
 202 10ff 20 5f 0a            JSR GETSL   ;LOAD THAT BYTE INTO ACC.
 203 1102 48                  PHA         ;SAVE IT.
 204                   
 205 1103 20 d5 0a            JSR INCSL   ;ADVANCE TO 2ND BYTE OF 
 206                                      ;OPERAND.
 207 1106 20 3d 0d            JSR DUMPSL  ;DUMP IT
 208 1109 68                  PLA         ;RESTORE FIRST BYTE TO THE ACC.
 209                   
 210 110a 20 39 0c            JSR PRBYT   ;DUMP IT
 211 110d 60                  RTS         ;RETURN TO CALLER.
 212                   ;********************************************
 213                   ;
 214                   ;PRINT LEFT, RIGHT PARENTHESIS
 215                   ;
 216                   ;********************************************
 217 110e a9 28        LPAREN LDA #$28    ;PRINT LEFT PAREN.
 218 1110 d0 02               BNE SENDIT  ;
 219                                      ;
 220 1112 a9 29        RPAREN LDA #$29    ;PRINT RIGHT PAREN.
 221                                      ;
 222 1114 20 f6 0b     SENDIT JSR PRCHR   ;
 223 1117 60                  RTS         ;
 224                   ;********************************************
 225                   ;
 226                   ;PRINT A COMMA AND AN "X"
 227                   ;
 228                   ;********************************************
 229 1118 a9 2c        XINDEX LDA #$2C
 230 111a 20 f6 0b            JSR PRCHR   ;PRINT A COMMA.
 231 111d a9 58               LDA #"x"
 232 111f 20 f6 0b            JSR PRCHR   ;PRINT AN "X"
 233 1122 60                  RTS
 234                   ;********************************************
 235                   ;
 236                   ;PRINT A COMMA AND AN "Y"
 237                   ;
 238                   ;********************************************
 239 1123 a9 2c        YINDEX LDA #$2C
 240 1125 20 f6 0b            JSR PRCHR   ;PRINT A COMMA.
 241 1128 a9 59               LDA #"y"
 242 112a 20 f6 0b            JSR PRCHR   ;PRINT AN "Y"
 243 112d 60                  RTS
 244                   ;********************************************
 245                   ;
 246                   ;FINISH THE LINE
 247                   ;
 248                   ;********************************************
 249                                      ;NOTE: EVERY ADDRESSING MODE
 250                                      ;      SUBROUTINE MUST END BY
 251                                      ;      SETTING X EQUAL TO THE
 252                                      ;      NUMBER OF BYTES IN THE
 253                                      ;      OPERAND, AND ACC EQUAL
 254                                      ;      TO THE NUMBER OF
 255                                      ;      CHARACTERS IN OPERAND.
 256                   
 257 112e 8d 39 10     FINISH STA OPCHRS  ;SAVE THE LENGTH OF THE
 258 1131 8e 38 10            STX OPBYTS  ;OPERAND, IN CHARACTERS AND
 259                                      ;IN BYTES. 0 MEANS NO
 260                                      ;OPERAND.
 261                                      ;
 262 1134 ca                  DEX         ;IF NECESSARY, DECREMENT THE
 263                                      ;SELECT POINTER SO IT POINTS
 264 1135 30 06               BMI SELOK   ;TO THE OPCODE.
 265 1137 20 e2 0a     LOOPS1 JSR DECSL   ;
 266 113a ca                  DEX         ;
 267 113b 10 fa               BPL LOOPS1  ;
 268                                      ;
 269                                      ;NOW SELECT POINTS TO OPCODE.
 270                                      ;
 271 113d 08           SELOK  PHP         ;SAVE CALLER'S DECIMAL FLAG.
 272 113e d8                  CLD         ;PREPARE FOR BINARY ADDITION.
 273                                      ;
 274 113f 38                  SEC         ;SPACE OVER TO THE COLUMN
 275 1140 ad 3a 10            LDA ADRCOL  ;FOR THE ADDRESS FIELD:
 276 1143 e9 04               SBC #4      ;OPERAND FIELD STARTED IN
 277                                      ;COLUMN 4...
 278 1145 ed 39 10            SBC OPCHRS  ;AND INCLUDES OPCHRS
 279                                      ;CHARACTERS.
 280 1148 28                  PLP         ;RESTORE CALLER'S DECIMAL FLAG
 281 1149 aa                  TAX         ;
 282 114a 20 4c 0c            JSR SPACES  ;PRINT ENOUGH SPACES TO
 283                                      ;REACH ADDRESS COLUMN.
 284                                      ;
 285 114d 20 44 0d            JSR PRADR   ;PRINT ADDRESS OF OPCODE.
 286 1150 20 33 0c            JSR SPACEO  ;SPACE AFTER OPCODE'S ADDRESS.
 287                                      ;
 288 1153 20 3d 0d     LOOPS2 JSR DUMPSL  ;DUMP SELECTED BYTE.
 289                                      ;
 290 1156 ad 19 08            LDA TVCOLS  ;IS SCREEN < 24 COLUMNS WIDE?
 291 1159 38                  SEC         ;
 292 115a c9 18               CMP #24     ;
 293 115c 90 03               BCC DUMPED  ;IF SO, DON'T SPACE AGAIN.
 294                                      ;
 295                                      ;SCREEN IS > 24 COLUMNS WIDE.
 296                                      ;
 297 115e 20 33 0c            JSR SPACEO  ;SO SPACE AFTER DUMPING BYTE.
 298                                      ;
 299                                      ;WE'VE DUMPED SELECTED BYTE.
 300 1161 20 d5 0a     DUMPED JSR INCSL   ;SELECT NEXT BYTE.
 301 1164 ce 38 10            DEC OPBYTS  ;DUMPED LAST BYTE IN
 302                                      ;INSTRUCTION?
 303 1167 10 ea               BPL LOOPS2  ;IF NOT, DUMP NEXT BYTE.
 304 1169 20 e2 0a            JSR DECSL   ;BACK UP SELECT, SO IT POINTS
 305                                      ;TO LAST BYTE IN OPERAND.
 306                                      ;
 307                                      ;IF SO, GO TO A NEW LINE:
 308                                      ;
 309 116c 20 28 0c     FINEND JSR CRLF    ;HAVING DISASSEMBLED ONE LINE,
 310                                      ;GO TO A NEW LINE.
 311 116f 60                  RTS         ;RETURN TO CALLER.
 312                   ;********************************************
 313                   ;
 314                   ;ADDRESSING MODE SUBROUTINES
 315                   ;
 316                   ;********************************************
 317                   
 318                   ;********************************************
 319                   ;
 320                   ;ABSOLUTE MODE
 321                   ;
 322                   ;********************************************
 323 1170 20 fc 10     ABSLUT JSR TWOBYT ;PRINT A TWO-BYTE OPERAND
 324 1173 a2 02               LDX #2     ;OPERAND HAS TWO BYTES...
 325 1175 a9 04               LDA #4     ;...AND FOUR CHARACTERS.
 326 1177 60                  RTS        ;RETURN TO CALLER.        
 327                   ;********************************************
 328                   ;
 329                   ;ABSOLUTE,X MODE
 330                   ;
 331                   ;********************************************
 332 1178 20 70 11     ABSX  JSR ABSLUT
 333 117b 20 18 11           JSR XINDEX   ;PRINT A COMMA AND AN "X"
 334 117e a2 02              LDX #2       ;OPERAND HAS 2 BYTES...
 335 1180 a9 06              LDA #6       ;...AND SIX CHARACTERS.
 336 1182 60                 RTS          ;RETURN TO CALLER.
 337                   ;********************************************
 338                   ;
 339                   ;ABSOLUTE,Y MODE
 340                   ;
 341                   ;********************************************
 342 1183 20 70 11     ABSY  JSR ABSLUT
 343 1186 20 23 11           JSR YINDEX   ;PRINT A COMMA AND AN "Y"
 344 1189 a2 02              LDX #2       ;OPERAND HAS 2 BYTES...
 345 118b a9 06              LDA #6       ;...AND SIX CHARACTERS.
 346 118d 60                 RTS          ;RETURN TO CALLER.
 347                   ;********************************************
 348                   ;
 349                   ;ACCUMULATOR MODE
 350                   ;
 351                   ;********************************************
 352 118e a9 c1        ACC    LDA #"A"    ;PRINT THE LETTER "A".
 353 1190 20 f6 0b            JSR PRCHR
 354 1193 a2 00               LDX #0      ;OPERAND HAS NO BYTES.
 355 1195 a9 01               LDA #1      ;...AND ONE CHARACTER
 356 1197 60                  RTS         ;RETURUN TO CALLER
 357                   ;********************************************
 358                   ;
 359                   ;IMPLIED MODE
 360                   ;
 361                   ;********************************************
 362 1198 a2 00        IMPLID LDX #0      ;OPERAND HAS NO BYTES...
 363 119a a9 00               LDA #0      ;...AND NO CHARACTERS.
 364 119c 60                  RTS
 365                   ;********************************************
 366                   ;
 367                   ;IMMEDIATE MODE
 368                   ;
 369                   ;********************************************
 370 119d a9 23        IMMEDT LDA #"#"    ;PRINT A "#" CHARACTER.
 371 119f 20 f6 0b            JSR PRCHR   ;
 372                                      ;
 373 11a2 a9 24               LDA #"$"    ;PRINT A DOLLAR SIGN TO
 374 11a4 20 f6 0b            JSR PRCHR   ;INDICATE HEXADECIMAL
 375 11a7 20 f5 10            JSR ONEBYT  ;PRINT ONE-BYTE OPERAND IN
 376                                      ;HEXADECIMAL FORMAT.
 377 11aa a2 01               LDX #1      ;OPERAND HAS ONE BYTE...
 378 11ac a9 04               LDA #4      ;...AND FOUR CHARACTERS.
 379 11ae 60                  RTS         ;RETURN TO CALLER.
 380                   ;********************************************
 381                   ;
 382                   ;INDIRECT MODE
 383                   ;
 384                   ;********************************************
 385 11af 20 0e 11     INDRCT JSR LPAREN  ;PRINT LEFT PARENTHESIS.
 386 11b2 20 70 11            JSR ABSLUT  ;PRINT TWO-BYTE OPERAND.
 387 11b5 20 12 11            JSR RPAREN  ;PRINT RIGHT PARENTHESIS.
 388 11b8 a9 06               LDA #6      ;A HOLDS NUMBER OF CHARACTERS
 389                                      ;IN OPERAND.
 390 11ba a2 02               LDX #2      ;X HOLDS NUMBER OF BYTES IN
 391                                      ;OPERAND.
 392 11bc 60                  RTS         ;RETURN TO CALLER.
 393                   ;********************************************
 394                   ;
 395                   ;INDIRECT,X MODE
 396                   ;
 397                   ;********************************************
 398 11bd 20 0e 11     INDX  JSR LPAREN   ;PRINT A ZERO PAGE ADDRESS,
 399 11c0 20 13 12           JSR ZEROX    ;A COMMA, AND THE LETTER "X".
 400                                      ;
 401 11c3 20 12 11           JSR RPAREN   ;
 402 11c6 a2 01              LDX #1       ;ONE BYTE IN OPERAND.
 403 11c8 a9 06              LDA #6       ;6 CHARACTERS IN OPERAND.
 404 11ca 60                 RTS          ;
 405                   ;********************************************
 406                   ;
 407                   ;INDIRECT,Y MODE
 408                   ;
 409                   ;********************************************
 410 11cb 20 0e 11     INDY  JSR LPAREN   ;
 411 11ce 20 0b 12           JSR ZEROPG   ;PRINT A ZERO PAGE ADDRESS,
 412 11d1 20 12 11           JSR RPAREN   ;
 413 11d4 20 23 11           JSR YINDEX   ;PRINT A COMMA AND A "Y"
 414 11d7 a2 01              LDX #1       ;OPERAND HAS 1 BYTE...
 415 11d9 a9 06              LDA #6       ;...AND 6 CHARACTERS.
 416 11db 60                 RTS          ;
 417                   ;********************************************
 418                   ;
 419                   ;RELATIVE MODE
 420                   ;
 421                   ;********************************************
 422 11dc 20 d5 0a     RELATV JSR INCSL    ;SELECT NEXT BYTE.
 423 11df 20 c8 0c            JSR PUSHSL   ;SAVE SELECT POINTER ON STACK.
 424 11e2 20 5f 0a            JSR GETSL    ;GET OPERAND BYTE.
 425 11e5 48                  PHA          ;SAVE IT ON STACK.
 426 11e6 20 d5 0a            JSR INCSL    ;INCREMENT SELECT POINTER
 427                                       ;SO IT POINTS TO NEXT OPCODE.
 428                                       ;(RELATIVE BRANCHES ARE
 429                                       ;RELATIVE TO NEXT OPCODE.)
 430 11e9 68                  PLA          ;RESTORE OPERAND BYTE TO ACC.
 431 11ea c9 00               CMP #0       ;IS IT PLUS OR MINUS?
 432 11ec 10 03               BPL FORWRD   ;IF PLUS, IT MEANS A FORWARD
 433                                       ;BRANCH.
 434                                       ;
 435                                       ;OPERAND IS MINUS, SO WE'LL
 436                                       ;BRANCH BACKWARD.
 437 11ee ce c6 09            DEC SELECT+1 ;BRANCHING BACKWARD IS LIKE
 438                                       ;BRANCHING FORWARD FROM ONE
 439                                       ;PAGE LOWER IN MEMORY.
 440 11f1 08           FORWRD PHP          ;
 441 11f2 d8                  CLD          ;SAVE CALLER'S DECIMAL FLAG.
 442                                       ;CLEAR DECIMAL MODE, FOR
 443                                       ;BINARY ADDITION.
 444 11f3 18                  CLC          ;PREPARE TO ADD.
 445 11f4 6d c5 09            ADC SELECT   ;ADD OPERAND BYTE TO SELECT.
 446 11f7 90 03               BCC RELEND   ;
 447 11f9 ee c6 09            INC SELECT+1 ;
 448 11fc 8d c5 09     RELEND STA SELECT   ;NOW SELECT POINTS TO ADDRESS
 449                                       ;SPECIFIED BY RELATIVE
 450                                       ;BRANCH INSTRUCTION.
 451 11ff 28                  PLP          ;RESTORE CALLER'S DECIMAL
 452                                       ;FLAG.
 453 1200 20 44 0d            JSR PRADR    ;PRINT ADDRESS SPECIFIED
 454                                       ;BY INSTRUCTION.
 455 1203 20 e1 0c            JSR POPSL    ;MAKE SELECT POINT TO
 456                                       ;ADDRESS OF OPERAND.
 457 1206 a2 01               LDX #1       ;OPERAND HAD ONE BYTE...
 458 1208 a9 04               LDA #4       ;AND FOUR CHARACTERS.
 459 120a 60                  RTS          ;RETURN TO CALLER.
 460                   ;********************************************
 461                   ;
 462                   ;ZERO PAGE MODE
 463                   ;
 464                   ;********************************************
 465 120b 20 f5 10     ZEROPG JSR ONEBYT  ;PRINT ONE-BYTE OPERAND.
 466 120e a2 01               LDX #1      ;OPERAND HAS ONE BYTE...
 467 1210 a9 02               LDA #2      ;AND TWO CHARACTERS.
 468 1212 60                  RTS
 469                   ;********************************************
 470                   ;
 471                   ;ZERO PAGE, X MODE
 472                   ;
 473                   ;********************************************
 474 1213 20 0b 12     ZEROX  JSR ZEROPG  ;PRINT THE ZERO PAGE ADDRESS.
 475 1216 20 18 11            JSR XINDEX  ;PRINT A COMMA AND AN "X".
 476 1219 a2 01               LDX #1      ;OPERAND HAS 1 BYTE...
 477 121b a9 04               LDA #4      ;...AND FOUR CHARACTERS.
 478 121d 60                  RTS         ;RETURN TO CALLER.
 479                   ;********************************************
 480                   ;
 481                   ;ZERO PAGE, Y MODE
 482                   ;
 483                   ;********************************************
 484 121e 20 0b 12     ZEROY  JSR ZEROPG  ;PRINT THE ZERO PAGE ADDRESS.
 485 1221 20 23 11            JSR YINDEX  ;PRINT A COMMA AND AN "X".
 486 1224 a2 01               LDX #1      ;OPERAND HAS 1 BYTE...
 487 1226 a9 04               LDA #4      ;...AND FOUR CHARACTERS.
 488 1228 60                  RTS         ;RETURN TO CALLER.
 489                   ;********************************************
 490                   ;
 491                   ;A PSEUDO-ADDRESSING MODE
 492                   ;FOR EMBEDDED TEXT: TEXT MODE.
 493                   ;
 494                   ;********************************************
 495                   
 496                   ;********************************************
 497                   ;
 498                   ;THE PSEUDO-OPCODE TEX <$7F> BEGINS ANY
 499                   ;STRING OF TEXT AND PRINT CONTROL CHARACTERS.
 500                   ;THE PSEUDO-TEXT CHARACTER ETX <*FF> ENDS ANY
 501                   ;SUCH STRING. TEX HAS A PSEUDO-ADDRESSING
 502                   ;MODE: TEXT MODE. IN TEXT MODE, WE PRINT THE
 503                   ;STRING AND RETURN, WITHOUT DUMPING THE LINE
 504                   ;IN HEX. THE STRING MAY BE OF ANY LENGTH.
 505                   ;
 506                   ;********************************************
 507 1229 68           TXMODE PLA          ;POP RETURN ADDRESS TO
 508 122a 68                  PLA          ;OPERND.
 509                                       ;
 510 122b 68                  PLA          ;POP REJURN ADDRESS TO
 511 122c 68                  PLA          ;DSLINE.
 512                                       ;
 513                                       ;NOW DSLINE'S CALLER IS ON
 514                                       ;THE STACK.
 515                                       ;
 516 122d 20 08 10            JSR NEXTSL   ;ADVANCE PAST TEX PSEUDO-OP.
 517 1230 30 0d               BMI TXEXIT   ;RETURN IF REACHED EA.
 518 1232 20 5f 0a            JSR GETSL    ;GET THE CHARACTER.
 519 1235 c9 ff               CMP #ETX     ;IT END OF TEXT?
 520 1237 f0 06               BEQ TXEXIT   ;IF SO, STRING ENDED.
 521 1239 20 f6 0b            JSR PRCHR    ;IF NOT, PRINT CHARACTER.
 522 123c 18                  CLC          ;BRANCH BACK TO GET NEXT
 523 123d 90 ee               BCC TXMODE+4 ;CHARACTER.
 524 123f 20 28 0c     TXEXIT JSR CRLF     ;ADVANCE TO A NEW LINE.
 525 1242 20 08 10            JSR NEXTSL   ;ADVANCE TO NEXT OPCODE.
 526 1245 60                  RTS          ;RETURN TO CALLER OF DSLINE.
 527                   ;********************************************
 528                   ;
 529                   ;TABLE OF ADDRESSING MODE SUBROUTINES
 530                   ;
 531                   ;********************************************
 532 1246 98 11        SUBS .WORD IMPLID  ;ADDRESSING MODE 0 IS INVALID,
 533                                      ;HENCE IMPLIED.
 534 1248 8e 11             .WORD ACC
 535 124a 9d 11             .WORD IMMEDT
 536 124c 0b 12             .WORD ZEROPG
 537 124e 13 12             .WORD ZEROX
 538 1250 1e 12             .WORD ZEROY
 539 1252 70 11             .WORD ABSLUT
 540 1254 78 11             .WORD ABSX
 541 1256 83 11             .WORD ABSY
 542 1258 98 11             .WORD IMPLID
 543 125a dc 11             .WORD RELATV
 544 125c bd 11             .WORD INDX
 545 125e cb 11             .WORD INDY
 546 1260 af 11             .WORD INDRCT
 547 1262 29 12             .WORD TXMODE
 548                   ;********************************************
 549                   ;
 550                   ;LIST OF MNEMONICS
 551                   ;
 552                   ;********************************************
 553 1264 7f           MNAMES .BYTE TEX  ;SINCE THIS TABLE IS A
 554                                     ;STRING OF CHARACTERS, START
 555                                     ;IT WITH THE TEX PSEUDO-OP.
 556 1265 42 41 44            .TEXT "BAD"
 557 1268 41 44 43            .TEXT "ADC"
 558 126b 41 4e 44            .TEXT "AND"
 559 126e 41 53 4c            .TEXT "ASL"
 560 1271 42 43 43            .TEXT "BCC"
 561 1274 42 43 53            .TEXT "BCS"
 562 1277 42 45 51            .TEXT "BEQ"
 563 127a 42 49 54            .TEXT "BIT"
 564 127d 42 4d 49            .TEXT "BMI"
 565 1280 42 4e 45            .TEXT "BNE"
 566 1283 42 50 4c            .TEXT "BPL"
 567 1286 42 52 4b            .TEXT "BRK"
 568 1289 42 56 43            .TEXT "BVC"
 569 128c 42 56 53            .TEXT "BVS"
 570 128f 43 4c 43            .TEXT "CLC"
 571 1292 43 4c 44            .TEXT "CLD"
 572 1295 43 4c 49            .TEXT "CLI"
 573 1298 43 4c 56            .TEXT "CLV"
 574 129b 43 4d 50            .TEXT "CMP"
 575 129e 43 50 58            .TEXT "CPX"
 576 12a1 43 50 59            .TEXT "CPY"
 577 12a4 44 45 43            .TEXT "DEC"
 578 12a7 44 45 58            .TEXT "DEX"
 579 12aa 44 45 59            .TEXT "DEY"
 580 12ad 45 4f 52            .TEXT "EOR"
 581 12b0 49 4e 43            .TEXT "INC"
 582 12b3 49 4e 58            .TEXT "INX"
 583 12b6 49 4e 59            .TEXT "INY"
 584 12b9 4a 4d 50            .TEXT "JMP"
 585 12bc 4a 53 52            .TEXT "JSR"
 586 12bf 4c 44 41            .TEXT "LDA"
 587 12c2 4c 44 58            .TEXT "LDX"
 588 12c5 4c 44 59            .TEXT "LDY"
 589 12c8 4c 53 52            .TEXT "LSR"
 590 12cb 4e 4f 50            .TEXT "NOP"
 591 12ce 4f 52 41            .TEXT "ORA"
 592 12d1 50 48 41            .TEXT "PHA"
 593 12d4 50 48 50            .TEXT "PHP"
 594 12d7 50 4c 41            .TEXT "PLA"
 595 12da 50 4c 50            .TEXT "PLP"
 596 12dd 52 4f 4c            .TEXT "ROL"
 597 12e0 52 4f 52            .TEXT "ROR"
 598 12e3 52 54 49            .TEXT "RTI"
 599 12e6 52 54 53            .TEXT "RTS"
 600 12e9 53 42 43            .TEXT "SBC"
 601 12ec 53 45 43            .TEXT "SEC"
 602 12ef 53 45 44            .TEXT "SED"
 603 12f2 53 45 49            .TEXT "SEI"
 604 12f5 53 54 41            .TEXT "STA"
 605 12f8 53 54 58            .TEXT "STX"
 606 12fb 53 54 59            .TEXT "STY"
 607 12fe 54 41 58            .TEXT "TAX"
 608 1301 54 41 59            .TEXT "TAY"
 609 1304 54 53 58            .TEXT "TSX"
 610 1307 54 58 41            .TEXT "TXA"
 611 130a 54 58 53            .TEXT "TXS"
 612 130d 54 59 41            .TEXT "TYA"
 613 1310 54 45 58            .TEXT "TEX"
 614 1313 ff           .BYTE ETX          ;SINCE THIS IS THE END OF A
 615                                      ;STRING OF CHARACTERS, USE
 616                                      ;ETX TO INDICATE END OF TEXT.
 617                   ;********************************************
 618                   ;
 619                   ;TABLE OF MNEMONIC CODES
 620                   ;
 621                   ; A MNEMONICS CODE IS ITS OFFSET INTO
 622                   ; MNAMES, THE LIST OF MNEONIC NAMES.
 623                   ;
 624                   ;********************************************
 625 1314 22 6a 01 01  MCODES .BYTE $22,$6A,  1,  1,  1,$6A,$0A,  1
     1318 01 6a 0a 01 
 626 131c 70 6a 0a 01         .BYTE $70,$6A,$0A,  1,  1,$6A,$0A,  1
     1320 01 6a 0a 01 
 627 1324 1f 6a 01 01         .BYTE $1F,$6A,  1,  1,  1,$6A,$0A,  1
     1328 01 6a 0a 01 
 628 132c 2b 6a 01 01         .BYTE $2B,$6A,  1,  1,  1,$6A,$0A,  1
     1330 01 6a 0a 01 
 629 1334 58 07 01 01         .BYTE $58,  7,  1,  1,$16,  7,$79,  1
     1338 16 07 79 01 
 630 133c 76 07 79 01         .BYTE $76,  7,$79,  1,$16,  7,$79,  1
     1340 16 07 79 01 
 631 1344 19 07 01 01         .BYTE $19,  7,  1,  1,  1,  7,$79,  1
     1348 01 07 79 01 
 632 134c 88 07 01 01         .BYTE $88,  7,  1,  1,  1,  7,$79,  1
     1350 01 07 79 01 
 633 1354 7f 49 01 01         .BYTE $7F,$49,  1,  1,  1,$49,$64,  1
     1358 01 49 64 01 
 634 135c 6d 49 64 01         .BYTE $6D,$49,$64,  1,$55,$49,$64,  1
     1360 55 49 64 01 
 635 1364 25 49 01 01         .BYTE $25,$49,  1,  1,  1,$49,$64,  1
     1368 01 49 64 01 
 636 136c 31 49 01 01         .BYTE $31,$49,  1,  1,  1,$49,$64,  1
     1370 01 49 64 01 
 637 1374 82 04 01 01         .BYTE $82,  4,  1,  1,  1,  4,$7C,  1
     1378 01 04 7c 01 
 638 137c 73 04 7c 01         .BYTE $73,  4,$7C,  1,$55,  4,$7C,  1
     1380 55 04 7c 01 
 639 1384 28 04 01 01         .BYTE $28,  4,  1,  1,  1,  4,$7C,  1
     1388 01 04 7c 01 
 640 138c 8e 04 01 01         .BYTE $8E,  4,  1,  1,  1,  4,$7C,$AC
     1390 01 04 7c ac 
 641 1394 01 91 01 01         .BYTE   1,$91,  1,  1,$97,$91,$94,  1
     1398 97 91 94 01 
 642 139c 46 01 a3 01         .BYTE $46,  1,$A3,  1,$97,$91,$94,  1
     13a0 97 91 94 01 
 643 13a4 0d 91 01 01         .BYTE $0D,$91,  1,  1,$97,$91,$94,  1
     13a8 97 91 94 01 
 644 13ac a9 91 a3 01         .BYTE $A9,$91,$A3,  1,  1,$91,  1,  1
     13b0 01 91 01 01 
 645 13b4 61 5b 5e 01         .BYTE $61,$5B,$5E,  1,$61,$5B,$5E,  1
     13b8 61 5b 5e 01 
 646 13bc 9d 5b 9a 01         .BYTE $9D,$5B,$9A,  1,$61,$5B,$5E,  1
     13c0 61 5b 5e 01 
 647 13c4 10 5b 01 01         .BYTE $10,$5B,  1,  1,$61,$5B,$5E,  1
     13c8 61 5b 5e 01 
 648 13cc 34 5b 9e 01         .BYTE $34,$5B,$9E,  1,$61,$5B,$5E,  1
     13d0 61 5b 5e 01 
 649 13d4 3d 37 01 01         .BYTE $3D,$37,  1,  1,$3D,$37,$40,  1
     13d8 3d 37 40 01 
 650 13dc 52 37 43 01         .BYTE $52,$37,$43,  1,$3D,$37,$40,  1
     13e0 3d 37 40 01 
 651 13e4 1c 37 01 01         .BYTE $1C,$37,  1,  1,  1,$37,$40,  1
     13e8 01 37 40 01 
 652 13ec 2e 37 01 01         .BYTE $2E,$37,  1,  1,  1,$37,$40,  1
     13f0 01 37 40 01 
 653 13f4 3a 85 01 01         .BYTE $3A,$85,  1,  1,$3A,$B5,$4C,  1
     13f8 3a b5 4c 01 
 654 13fc 4f 85 67 01         .BYTE $4F,$85,$67,  1,$3A,$85,$4C,  1
     1400 3a 85 4c 01 
 655 1404 13 85 01 01         .BYTE $13,$85,  1,  1,  1,$85,$4C,  1
     1408 01 85 4c 01 
 656 140c 8b 85 01 01         .BYTE $8B,$85,  1,  1,  1,$85,$4C,  1       
     1410 01 85 4c 01 
 657                   ;********************************************
 658                   ;
 659                   ;TABLE OF ADDRESSING MODE CODES
 660                   ;
 661                   ;AN ADDRESSING MODE'S CODE IS IT'S OFFSET
 662                   ;INTO SUBS, THE TABLE OF ADDRESSING MODE
 663                   ;SUBROUTINES.
 664                   ;
 665                   ;********************************************
 666 1414 12 16 00 00  MODES .BYTE 18,22, 0, 0, 0, 6, 6, 0
     1418 00 06 06 00 
 667 141c 12 04 02 00        .BYTE 18, 4, 2, 0, 0,12,12, 0
     1420 00 0c 0c 00 
 668 1424 14 18 00 00        .BYTE 20,24, 0, 0, 0,14,14, 0
     1428 00 0e 0e 00 
 669 142c 12 10 00 00        .BYTE 18,16, 0, 0, 0,22,22, 0
     1430 00 16 16 00 
 670 1434 0c 16 00 00        .BYTE 12,22, 0, 0, 6, 6, 6, 0
     1438 06 06 06 00 
 671 143c 12 04 02 00        .BYTE 18, 4, 2, 0,12,12,12, 0
     1440 0c 0c 0c 00 
 672 1444 14 18 00 00        .BYTE 20,24, 0, 0, 0, 8, 8, 0
     1448 00 08 08 00 
 673 144c 12 10 00 00        .BYTE 18,16, 0, 0, 0,14,14, 0
     1450 00 0e 0e 00 
 674 1454 12 16 00 00        .BYTE 18,22, 0, 0, 0, 6, 6, 0
     1458 00 06 06 00 
 675 145c 12 0c 02 00        .BYTE 18,12, 2, 0,12,12,12, 0
     1460 0c 0c 0c 00 
 676 1464 14 18 00 00        .BYTE 20,24, 0, 0, 0, 8, 8, 0
     1468 00 08 08 00 
 677 146c 12 10 00 00        .BYTE 18,16, 0, 0, 0,14,14, 0
     1470 00 0e 0e 00 
 678 1474 12 16 00 00        .BYTE 18,22, 0, 0, 0, 6, 6, 0
     1478 00 06 06 00 
 679 147c 12 04 02 00        .BYTE 18, 4, 2, 0,26,12,12, 0
     1480 1a 0c 0c 00 
 680 1484 14 18 00 00        .BYTE 20,24, 0, 0, 0, 8, 8, 0
     1488 00 08 08 00 
 681 148c 12 10 00 00        .BYTE 18,16, 0, 0, 0, 4,14,28
     1490 00 04 0e 1c 
 682 1494 00 16 00 00        .BYTE 0 ,22, 0, 0, 6, 6, 6, 0
     1498 06 06 06 00 
 683 149c 12 00 12 00        .BYTE 18, 0,18, 0,12,12,12, 0
     14a0 0c 0c 0c 00 
 684 14a4 14 18 00 00        .BYTE 20,24, 0, 0, 8, 8,10, 0
     14a8 08 08 0a 00 
 685 14ac 12 10 12 00        .BYTE 18,16,18, 0, 0,14, 0, 0
     14b0 00 0e 00 00 
 686 14b4 04 16 04 00        .BYTE  4,22, 4, 0, 6, 6, 6, 0
     14b8 06 06 06 00 
 687 14bc 12 04 12 00        .BYTE 18, 4,18, 0,12,12,12, 0
     14c0 0c 0c 0c 00 
 688 14c4 14 18 00 00        .BYTE 20,24, 0, 0, 8, 8,10, 0
     14c8 08 08 0a 00 
 689 14cc 14 10 12 00        .BYTE 20,16,18, 0,14,14,16, 0
     14d0 0e 0e 10 00 
 690 14d4 04 16 00 00        .BYTE  4,22, 0, 0, 6, 6, 6, 0
     14d8 06 06 06 00 
 691 14dc 12 04 12 00        .BYTE 18, 4,18, 0,12,12,12, 0
     14e0 0c 0c 0c 00 
 692 14e4 14 18 00 00        .BYTE 20,24, 0, 0, 0, 8, 8, 0
     14e8 00 08 08 00 
 693 14ec 12 10 00 00        .BYTE 18,16, 0, 0, 0,14,14, 0
     14f0 00 0e 0e 00 
 694 14f4 04 16 00 00        .BYTE  4,22, 0, 0, 6, 6, 6, 0
     14f8 06 06 06 00 
 695 14fc 12 04 12 00        .BYTE 18, 4,18, 0,12,12,12, 0
     1500 0c 0c 0c 00 
 696 1504 14 18 00 00        .BYTE 20,24, 0, 0, 0, 8, 8, 0
     1508 00 08 08 00 
 697 150c 12 10 00 00        .BYTE 18,16, 0, 0, 0,14,14, 0
     1510 00 0e 0e 00 
 698                   ;********************************************
 699                   ;
 700                   ;
 701                   ;
 702                   ;********************************************
 703                   
 704                   ;********************************************
 705                   ;
 706                   ;SET STARTING ADDRESS, ENDING ADDRESS
 707                   ;TEST MODE
 708                   ;
 709                   ;********************************************
 710 1514 20 be 0b     SETADI JSR TVTON    ;SELECT TVT AS AN OUTPUT DEVICE. ALL
 711                                       ;OTHER SELECTED OUTPUT DEVICES WILL ECHO
 712                                       ;THE SCREEN OUTPUT.
 713 1517 20 9a 0c            JSR PRINTX   ;PUT PROMPT ON THE SCREEN:
 714 151a 7f                  .BYTE TEX    ;
 715 151b 0d 0a 0a            .BYTE CR,LF,LF                ;
 716 151e 53 45 54 20         .TEXT "SET STARTING ADDRESS " ;
     1522 53 54 41 52 
     1526 54 49 4e 47 
     152a 20 41 44 44 
     152e 52 45 53 53 
     1532 20 
 717 1533 54 4f 20 4b         .TEXT "TO KERNAL"             ;
     1537 45 52 4e 41 
     153b 4c 
 718 153c 0d 0a               .BYTE CR,LF                   ;
 719 153e ff                  .BYTE ETX                     ;
 720                          ;JSR VISMON   ;CALL THE VISIBLE MONITOR, SO USER CAN
 721                          ;             ;SPECIFY A GIVEN ADDRESS.
 722 153f a9 00               LDA #<KERNAL ;
 723 1541 8d c5 09            STA SELECT   ;
 724 1544 a9 e0               LDA #>KERNAL ;
 725 1546 8d c6 09            STA SELECT+1 ;
 726                                       ;
 727 1549 20 72 0e            JSR SAHERE   ;SET STARTING ADDRESS EQUAL TO ADDRESS SET
 728                                       ;BY THE USER.
 729 154c 20 9a 0c            JSR PRINTX   ;PUT PROMPT ON THE SCREEN:
 730 154f 7f                  .BYTE TEX
 731 1550 0d 0a 0a            .BYTE CR,LF,LF
 732 1553 53 45 54 20         .TEXT "SET ENDING ADDRESS "
     1557 45 4e 44 49 
     155b 4e 47 20 41 
     155f 44 44 52 45 
     1563 53 53 20 
 733 1566 4b 45 52 45         .TEXT "KEREND" 
     156a 4e 44 
 734 156c 0d 0a               .BYTE CR,LF                   ;
 735 156e ff                  .BYTE ETX
 736                          ;JSR VISMON   ;CALL THE VISIBLE MONITOR, SO USER CAN
 737                          ;             ;SPECIFY A GIVEN ADDRESS.
 738 156f a9 ff               LDA #<KEREND ;
 739 1571 8d c5 09            STA SELECT   ;
 740 1574 a9 e0               LDA #>KEREND ;
 741 1576 8d c6 09            STA SELECT+1 ;
 742                                       ;
 743 1579 20 65 0e            JSR EAHERE   ;
 744                                       ;
 745 157c 60                  RTS          ;
 746                   ;********************************************
 747                   ;
 748                   ;
 749                   ;
 750                   ;********************************************
 752                   
  86                   .endif
  87                   ;****************************
  88                   ; A GENERAL MOVE UTILITY
  89                   ;****************************
  90                   .ifne CHAP10
  91                   .include "CHAPTER10.ASM"
   1                   ;********************************************
   2                   ;A GENERAL MOVE UTILITY
   3                   ;
   4                   ;APPENDIX C9: ASSEMBLER LISTING OF
   5                   ;MOVE UTILITIES
   6                   ;SEE CHAPTER 10 OF TOP-DOWN ASSEMBLY LANGUAGE
   7                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   8                   ;BY KEN SKIER
   9                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
  10                   ;LEXINGTON, MASSACHUSETTS
  11                   ;
  12                   ;********************************************
  13                   
  14                   ;********************************************
  15                   ;
  16                   ;MOVE TOOL STORAGE
  17                   ;
  18                   ;********************************************
  19 157d 00 00        NUM .WORD 0  ;NUMBER OF BYTES IN BLOCK
  20                                ;TO BE MOVED. ZERO MEANS
  21                                ;BLOCK CONTAINS 1 BYTE.
  22 157f 00 00        DEST .WORD 0 ;POINTER TO BLOCK'S
  23                                ;DESTINATION.
  24                   ;********************************************
  25                   ;
  26                   ;MOVE TOOL RETUNRN CODES
  27                   ;
  28                   ;********************************************
  29                   ERROR = 0     ;THIS RETURN CODE MEANS
  30                                 ;SA < EA, SO MOVE ABORTED.
  31                   OKAY  = $FF   ;THIS RETURN CODE MEANS
  32                                 ;MOVE ACCOMPLISHED.
  33                   ;********************************************
  34                   ;
  35                   ;MOVER
  36                   ;
  37                   ;********************************************
  38 1581 20 be 0b     MOVER  JSR TVTON          ;Select screen as an output device.
  39 1584 20 9a 0c            JSR PRINTX         ;DISPLAY A TITLE
  40 1587 7f                  .BYTE TEX
  41 1588 0d                  .BYTE CR
  42 1589 20 4d 4f 56         .TEXT" MOVE TOOL"
     158d 45 20 54 4f 
     1591 4f 4c 
  43 1593 0d 0a 0a            .BYTE CR,LF,LF
  44 1596 ff                  .BYTE ETX
  45                   ;
  46 1597 20 f5 0d            JSR SETADS        ;Get start address,END
  47                                            ;ADDRESS FROM USER
  48                   ;
  49 159a 20 b0 16            JSR SETDA         ;GET DESTINATION ADDRESS
  50                                            ;FROM USER.
  51                                            ;WITH THOSE POINTERS SET,
  52                                            ;WE'RE READY TO EXECUTE MOV.EA:
  53                   ;********************************************
  54                   ;
  55                   ;MOV.EA: MOVE BLOCK SPECIFIED BY SA, EA, DEST
  56                   ;
  57                   ;RETURN CODES:
  58                   ;
  59                   ;ERROR = 0      THIS RETURN CODE MEANS
  60                   ;                SA < EA, SO MOVE ABORTED.
  61                   ;OKAY  = $FF    THIS RETURN CODE MEANS
  62                   ;                MOVE ACCOMPLISHED.
  63                   ;
  64                   ;********************************************
  65 159d ae 15 08     MOVEA  LDX EA+1    ;SET NUM EQUAL TO EA - SA:
  66 15a0 38                  SEC
  67 15a1 ad 14 08            LDA EA
  68 15a4 ed 12 08            SBC SA
  69 15a7 8d 7d 15            STA NUM
  70 15aa b0 02               BCS MOVES
  71 15ac ca                  DEX
  72 15ad 38                  SEC
  73 15ae 8a           MOVES  TXA
  74 15af ed 13 08            SBC SA+1
  75 15b2 8d 7e 15            STA NUM+1
  76 15b5 b0 03               BCS MOVNUM
  77                   ;
  78 15b7 a9 00        ERRTN  LDA #ERROR  ;IF EA < SA,
  79 15b9 60                  RTS         ;RETURN WITH ERROR CODE.
  80                   ;********************************************
  81                   ;
  82                   ;MOVNUM: MOVE BLOCK SPECIFIED BY SA, NUM, DEST.
  83                   ;
  84                   ;********************************************
  85 15ba a0 03        MOVNUM LDY #3        ;SAVE ZERO PAGE BYTES THAT
  86 15bc b9 fd 00     LOOPMV LDA GETPTR,Y  ;WILL BE CHANGED.
  87                   ;
  88 15bf 48                  PHA
  89 15c0 88                  DEY
  90 15c1 10 f9               BPL LOOPMV
  91                   ;
  92 15c3 38                  SEC           ;IF DEST>SA, BRANCH TO MOVE-UP
  93 15c4 ad 13 08            LDA SA+1
  94 15c7 cd 80 15            CMP DEST+1
  95 15ca 90 40               BCC MOVEUP
  96 15cc d0 18               BNE MOVEDN
  97                                        ;IF DEST<SA, BRANCH TO
  98                                        ;MOVE-DOWN.
  99                   ;
 100 15ce ad 12 08            LDA SA
 101 15d1 cd 7f 15            CMP DEST
 102 15d4 90 36               BCC MOVEUP
 103 15d6 d0 0e               BNE MOVEDN    ;IF DEST EQUALS SA,
 104 15d8 a0 00        OKRTN  LDY #0        ;RETURN BEARING "OKAY" CODE.
 105                                        ;RESTORE ZERO PAGE BYTES
 106 15da 68           LOOPMO PLA           ;THAT WERE CHANGED.
 107 15db 99 fd 00            STA GETPTR,Y
 108 15de c8                  INY
 109 15df c0 04               CPY #4
 110 15e1 d0 f7               BNE LOOPMO
 111 15e3 a9 ff               LDA #OKAY     ;RETURN W/"OKAY" CODE.
 112 15e5 60                  RTS
 113                   ;********************************************
 114                   ;
 115                   ;Move-Down: MOVEDN
 116                   ;
 117                   ;********************************************
 118 15e6 20 6b 16     MOVEDN JSR LOPAGE     ;SET PAGE POINTERS TO LOWEST
 119                                         ;PAGES IN ORIGIN, DESTINATION
 120                                         ;BLOCKS.
 121 15e9 a0 00               LDY #0         ;INITIALIZE PAGE INDEX TO
 122                                         ;BOTTOM OF PAGE.
 123 15eb ae 7e 15            LDX NUM+1      ;USE X TO COUNT THE NUMBER
 124                                         ;OF PAGES TO MOVE. MORE THAN
 125                                         ;ONE PAGE TO MOVE?
 126 15ee f0 0e               BEQ LESSDN     ;IF NOT, MOVE LESS THAN A
 127                                         ;PAGE.
 128                   ;
 129                                         ;IF SO,
 130 15f0 b1 fd        PAGEDN LDA (GETPTR),Y ;MOVE A PAGE DOWN,
 131 15f2 91 fb               STA (PUTPTR),Y ;STARTING AT THE BOTTOM.
 132 15f4 c8                  INY            ;INCREMENT PAGE INDEX.
 133 15f5 d0 f9               BNE PAGEDN     ;IF PAGE NOT MOVED, MOVE
 134                                         ;NEXT BYTE...
 135                   ;
 136 15f7 e6 fe               INC GETPTR+1   ;Increment page pointers.
 137 15f9 e6 fc               INC PUTPTR+1
 138 15fb ca                  DEX            ;DECREMENT PAGE COUNT.
 139 15fc d0 f2               BNE PAGEDN     ;IF A PAGE LEFT TO MOVE,
 140                                         ;MOVE IT AS A PAGE.
 141                   ;
 142 15fe 88           LESSDN DEY            ;
 143 15ff c8                  INY            ;MOVE LESS THAN A PAGE
 144 1600 b1 fd               LDA (GETPTR),Y ;DOWN, STARTING AT THE
 145 1602 91 fb               STA (PUTPTR),Y ;BOTTOM.
 146 1604 cc 7d 15            CPY NUM        ;MOVED LAST BYTE?
 147 1607 d0 f6               BNE LESSDN+1   ;IF NOT, MOVE NEXT BYTE...
 148 1609 4c d8 15            JMP OKRTN      ;IF SO, RETURN BEARING
 149                                         ;"OKAY" CODE.
 150                   ;
 151 160c ad 7e 15     MOVEUP LDA NUM+1      ;MORE THAN A PAGE TO MOVE?
 152 160f f0 48               BEQ LESSUP     ;IF NOT, MOVE LESS THAN A
 153                                         ;PAGE.
 154                                         ;
 155                                         ;TO MOVE MORE THAN A PAGE,
 156                                         ;SET PAGE POINTERS TO
 157                                         ;HIGHEST PAGES IN ORIGIN,
 158                                         ;DESTINATION BLOCKS.
 159                                         ;
 160                                         ;TO DO THIS, FIRST SET
 161                                         ;(X,Y) EQUAL TO NUM - *FF,
 162                                         ;(RELATIVE ADDRESS OF
 163                                         ;HIGHEST PAGE IN A BLOCK-)
 164                                         ;
 165 1611 ac 7e 15            LDY NUM+1
 166 1614 ad 7d 15            LDA NUM
 167 1617 38                  SEC
 168 1618 e9 ff               SBC #$FF
 169 161a b0 01               BCS NEXTME
 170 161c 88                  DEY
 171                   ;
 172 161d aa           NEXTME TAX
 173                                         ;
 174                                         ;NOW (X,Y) - NUM - $FF.
 175                                         ;X IS LOW BYTE, Y IS HIGH BYTE
 176                                         ;
 177 161e 84 fc               STY PUTPTR+1
 178 1620 8a                  TXA
 179 1621 18                  CLC
 180 1622 6d 12 08            ADC SA
 181 1625 85 fd               STA GETPTR
 182 1627 90 01               BCC NEXTMN
 183 1629 c8                  INY
 184                   ;
 185 162a 98           NEXTMN TYA
 186 162b 6d 13 08            ADC SA+1
 187 162e 85 fe               STA GETPTR+1
 188                                        ;
 189                                        ;NOW GETPTR IS SA+NUM-*FF.
 190                                        ;(LAST PAGE IN SOURCE BLOCK-)
 191                                        ;
 192 1630 8a                  TXA
 193 1631 18                  CLC
 194 1632 6d 7f 15            ADC DEST
 195 1635 85 fb               STA PUTPTR
 196 1637 90 02               BCC NEXTMX
 197 1639 e6 fc               INC PUTPTR+1
 198                   ;
 199 163b a5 fc        NEXTMX LDA PUTPTR+1
 200 163d 6d 80 15            ADC DEST+1
 201 1640 85 fc               STA PUTPTR+1 
 202                                         ;
 203                                         ;NOW PUTPTR IS DEST+NUM-*FF.
 204                                         ;(LAST PAGE IN DEST BLOCK.)
 205                                         ;
 206 1642 ae 7e 15            LDX NUM+1      ;LOAD X WITH NUMBER OF
 207                                         ;PAGES TO MOVE.
 208                                         ;
 209 1645 a0 ff        PAGEUP LDY #$FF       ;SET PAGE INDEX TO TOP OF
 210                                         ;PAGE.
 211                                         ;
 212 1647 b1 fd        LOOPMR LDA (GETPTR),Y ;MOVE A PAGE UP, STARTING
 213 1649 91 fb               STA (PUTPTR),Y ;AT THE TOP OF THE BLOCK.
 214 164b 88                  DEY            ;DECREMENT PAGE INDEX.
 215                                         ;ABOUT TO MOVE LAST BYTE
 216                                         ;IN PAGE?
 217 164c d0 f9               BNE LOOPMR     ;IF NOT, HANDLE NEXT BYTE.
 218                                         ;AS BEFORE.
 219                   ;
 220 164e b1 fd               LDA (GETPTR),Y ;IF SO, MOVE THIS BYTE FROM
 221 1650 91 fb               STA (PUTPTR),Y ;SOURCE TO DESTINATION.
 222 1652 c6 fe               DEC GETPTR+1
 223 1654 c6 fc               DEC PUTPTR+1   ;DECREMENT PAGE POINTERS.
 224 1656 ca                  DEX            ;DECREMENT PAGE COUNTER.
 225 1657 d0 ec               BNE PAGEUP     ;IF A PAGE LEFT TO MOVE,
 226                                         ;MOVE IT AS A PAGE....
 227                   ;
 228 1659 20 6b 16     LESSUP JSR LOPAGE     ;MOVE LESS THAN A PAGE UP,
 229 165c ac 7d 15            LDY NUM        ;STARTING AT THE TOP.
 230                   ;
 231 165f b1 fd        MOVEIT LDA (GETPTR),Y ;COPY A BYTE FROM ORIGIN
 232 1661 91 fb               STA (PUTPTR),Y ;TO DESTINATION.
 233 1663 88                  DEY            ;DECREMENT PAGE INDEX.
 234 1664 c0 ff               CPY #$FF       ;COPIED THE LAST BYTE?
 235 1666 d0 f7               BNE MOVEIT     ;IF NOT, HANDLE AS BEFORE.
 236 1668 4c d8 15            JMP OKRTN      ;IF SO, RETURN BEARING
 237                                         ;"OKAY" CODE.
 238                   ;********************************************
 239                   ;
 240                   ;SET PAGE POINTERS TO BOTTOM OF
 241                   ;ORIGIN, DESTINATION BLOCKS.
 242                   ;
 243                   ;********************************************
 244 166b ad 12 08     LOPAGE LDA SA
 245 166e 85 fd               STA GETPTR
 246 1670 ad 13 08            LDA SA+1
 247 1673 85 fe               STA GETPTR+1
 248 1675 ad 7f 15            LDA DEST
 249 1678 85 fb               STA PUTPTR
 250 167a ad 80 15            LDA DEST+1
 251 167d 85 fc               STA PUTPTR+1
 252                   ;
 253 167f 60                  RTS
 254                   ;********************************************
 255                   ;
 256                   ;LET USER SET DESTINATION ADDRESS
 257                   ;
 258                   ;********************************************
 259 1680 20 be 0b     SETDAT JSR TVTON   ;LET USER SET DESTINATION
 260 1683 20 9a 0c            JSR PRINTX
 261 1686 7f 0d 0a            .BYTE TEX,CR,LF 
 262 1689 53 45 54 20         .TEXT "SET DESTINATION FREBOT"
     168d 44 45 53 54 
     1691 49 4e 41 54 
     1695 49 4f 4e 20 
     1699 46 52 45 42 
     169d 4f 54 
 263 169f 0d 0a               .BYTE CR,LF
 264 16a1 ff                  .BYTE ETX
 265                   ;
 266                          ;JSR VISMON    ;LET USER SET AN ADDRESS
 267                          
 268 16a2 a9 00               LDA #<FREBOT  ;
 269 16a4 8d c5 09            STA SELECT    ;
 270 16a7 a9 c4               LDA #>FREBOT  ;
 271 16a9 8d c6 09            STA SELECT+1  ;
 272                   ;
 273 16ac 20 dc 16            JSR DAHERE    ;
 274                   ;
 275 16af 60                  RTS           ;RETURN.
 276                   ;********************************************
 277                   ;
 278                   ;LET USER SET DESTINATION ADDRESS
 279                   ;
 280                   ;********************************************
 281 16b0 4c 80 16     SETDA  JMP SETDAT  ;TEST CODE
 282 16b3 20 be 0b            JSR TVTON   ;LET USER SET DESTINATION
 283 16b6 20 9a 0c            JSR PRINTX
 284 16b9 7f 0d 0a            .BYTE TEX,CR,LF 
 285 16bc 53 45 54 20         .TEXT "SET DESTINATION AND PRESS Q."
     16c0 44 45 53 54 
     16c4 49 4e 41 54 
     16c8 49 4f 4e 20 
     16cc 41 4e 44 20 
     16d0 50 52 45 53 
     16d4 53 20 51 2e 
 286 16d8 ff                  .BYTE ETX
 287                   ;
 288 16d9 20 da 09            JSR VISMON    ;LET USER SET AN ADDRESS
 289                   ;
 290 16dc ad c5 09     DAHERE LDA SELECT    ;
 291 16df 8d 7f 15            STA DEST      ;
 292 16e2 ad c6 09            LDA SELECT+1   ;
 293 16e5 8d 80 15            STA DEST+1     ;
 294                   ;
 295 16e8 60                  RTS           ;RETURN.
 296                   ;********************************************
 297                   ;
 298                   ;
 299                   ;
 300                   ;********************************************
 302                   
  92                   .endif
  93                   ;****************************
  94                   ; A SIMPLE TEXT EDITOR
  95                   ;****************************
  96                   .ifne CHAP11 
  97                   .include "CHAPTER11.ASM"
   1                   ;********************************************
   2                   ;A SIMPLE TEXT EDITOR
   3                   ;
   4                   ;APPENDIX C10: ASSEMBLER LISTING OF 
   5                   ;A SIMPLE TEXT EDITOR (TOP 
   6                   ;LEVEL AND DISPLAY SUBROUTINES)
   7                   ;SEE CHAPTER 11 OF TOP-DOWN ASSEMBLY LANGUAGE 
   8                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   9                   ;BY KEN SKIER
  10                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER 
  11                   ;LEXINGTON,MASSACHUSETTS
  12                   ;
  13                   ;********************************************
  14                   
  15                   ;********************************************
  16                   ;
  17                   ;CONSTANTS
  18                   ;
  19                   ;********************************************
  20                   INSCHR = "I"  ;GRAPHIC FOR INSERT MODE
  21                   OVRCHR = "O"  ;GRAPHIC FOR OVERSTRIKE MODE
  22                   ;********************************************
  23                   ;
  24                   ;VARIABLES
  25                   ;
  26                   ;********************************************
  27                   ;COUNTR .BYTE 0 ;COUNTER USED BY ELINE2.
  28                   ;
  29 16e9 00           EDMODE .BYTE 0 ;FLAG:0 FOR OVER STRIKE,
  30                                  ;1 FOR INSERT.
  31                   ;********************************************
  32                   ;
  33                   ;TEXT EDITOR :TOP LEVEL
  34                   ;
  35                   ;********************************************
  36 16ea 20 f6 16     EDITOR JSR SETBUF      ;INITIALIZ BUFFER POINTERS. 
  37 16ed 20 1d 17     EDLOOP JSR SHOWIT      ;SHOW USER A PORTION OF 
  38                                          ;EDIT BUFFER.
  39 16f0 20 ad 17            JSR EDITIT      ;LET THE USER EDIT THE BUFFER 
  40                                          ;OR MOVE ABOUT WITHIN IT.
  41 16f3 18                  CLC
  42 16f4 90 f7               BCC EDLOOP      ;LOOP BACK TO SHOW THE 
  43                                          ;CURRENT TEXT
  44                   ;********************************************
  45                   ;
  46                   ;INITIALIZE BUFFER POINTERS
  47                   ;
  48                   ;********************************************
  49 16f6 20 be 0b     SETBUF JSR TVTON       ;SELECT SCREEN.
  50 16f9 20 9a 0c            JSR PRINTX      ;DISPLAY "SET UP EDIT BUFFER."
  51 16fc 7f 0d 0a 0a 
  52 1700 53 45 54 20         .TEXT "SET UP EDIT BUFFER"
     1704 55 50 20 45 
     1708 44 49 54 20 
     170c 42 55 46 46 
     1710 45 52 
  53 1712 0d 0a 0a ff 
  54 1716 20 f5 0d     GETADS JSR SETADS      ;LET USER SET LOCATION AND
  55                                          ;SIZE OF EDIT BUFFER
  56 1719 20 25 10            JSR GOTOSA      ;MAKE SELECT PT TO START OF
  57                                          ;BUFFER...
  58 171c 60                  RTS             ;AND RETURN TO CALLER.
  59                   ;********************************************
  60                   ;
  61                   ;DISPLAY A PORTION OF EDIT BUFFER
  62                   ;
  63                   ;********************************************
  64 171d 20 a2 09     SHOWIT JSR TVPUSH  ;SAVE THE ZERO PAGE BYTES 
  65                                      ;WE'LL USE. 
  66 1720 20 09 09            JSR TVHOME  ;SET HOME POSITION OF EDIT 
  67                                      ;DISPLAY
  68                                      ;
  69 1723 ae 19 08            LDX TVCOLS  ;CLEAR THREE ROWS FOR
  70                          ;LDY #3      ;THE EDIT DISPLAY
  71 1726 a0 04               LDY #4      ;THE EDIT DISPLAY
  72 1728 20 f1 08            JSR CLRXY   ;
  73                                      ;
  74 172b 20 09 09            JSR TVHOME  ;RESTORE TV.PTR TO HOME 
  75                                      ;POSITION OF THE EDIT DISPLAY.
  76 172e 20 54 09            JSR TVDOWN  ;SET TV.PTR TO BEGINNING
  77 1731 20 a2 09            JSR TVPUSH  ;OF LINE TWO AND SAVE IT.
  78 1734 20 44 17            JSR ELINE2  ;DISPLAY TEXT IN LINE TWO.
  79                                      ;
  80 1737 20 b1 09            JSR TVPOP   ;SET TV.PTR TO BEGINNING OF
  81 173a 20 54 09            JSR TVDOWN  ;THIRD LINE OF EDIT
  82                                      ;DISPLAY
  83 173d 20 6e 17            JSR ELINE3  ;DISPLAY THIRD LINE OF EDIT
  84                                      ;DISPLAY
  85                                      ;
  86 1740 20 b1 09            JSR TVPOP   ;RESTORE ZERO-PAGE BYTES USED.
  87 1743 60                  RTS         ;RETURN TO CALLER, WITH EDIT 
  88                                      ;DISPLAY ON SCREEN, REST OF 
  89                                      ;SCREEN UNCHANGED, AND ZERO
  90                                      ;PAGE PRESERVED
  91                   ;********************************************
  92                   ;
  93                   ;ELINE2
  94                   ;
  95                   ;********************************************
  96 1744 20 c8 0c     ELINE2 JSR PUSHSL  ;SAVE SELECT POINTER
  97 1747 ad 19 08            LDA TVCOLS  ;SET X EQUAL TO
  98 174a 4a                  LSR A       ;HALF THE WIDTH
  99 174b aa                  TAX         ;OF THE SCREEN
 100 174c ca                  DEX         ;
 101                                      ;
 102 174d 20 e2 0a     LOOPEL JSR DECSL   ;DECREMENT SELECT...
 103 1750 ca                  DEX         ;
 104 1751 10 fa               BPL LOOPEL  ;...X TIMES.
 105                                      ;
 106 1753 ad 19 08            LDA TVCOLS  ;INITIALIZE COUNTR. 
 107 1756 8d fa 0c            STA COUNTR  ;(WE'RE DISPLAY TVCOLS
 108                                      ;CHARACTERS.)
 109 1759 20 5f 0a     LOOPE2 JSR GETSL   ;GET A CHARACTER FROM BUFFER.
 110 175c 20 79 09            JSR TVPUT   ;PUT IT ON SCREEN.
 111 175f 20 5d 09            JSR TVSKIP  ;GO TO NEXT SCREEN POSITION.
 112 1762 20 d5 0a            JSR INCSL   ;ADVANCE TO NEXT BYTE IN 
 113                                      ;BUFFER
 114 1765 ce fa 0c            DEC COUNTR  ;DONE LAST CHARACTER IN ROW?
 115 1768 10 ef               BPL LOOPE2  ;IF NOT, DO NEXT CHARACTER.
 116                                      ;
 117 176a 20 e1 0c            JSR POPSL   ;RESTORE SELECT FROM STACK.
 118 176d 60                  RTS         ;RETURN TO CALLER.
 119                   ;********************************************
 120                   ;
 121                   ;DISPLAY STATUS LINE
 122                   ;
 123                   ;********************************************
 124 176e ad 19 08     ELINE3 LDA TVCOLS   ;SELECT CENTER POSITION... 
 125 1771 4a                  LSR A        ;NOW A IS TVCOLS/2
 126 1772 e9 02               SBC #2       ;NOW A = (TVCOLS/2) - 2
 127 1774 20 5f 09            JSR TVPLUS   ;NOW TV.PTR IS POINTING TWO 
 128                                       ;CHARACTERS TO THE LEFT OF 
 129                                       ;CENTER OF LINE 3 OF THE EDIT
 130                                       ;DISPLAY.
 131 1777 ad e9 16            LDA EDMODE   ;WHAT IS CURRENT MODE?
 132 177a c9 01               CMP #1       ;IS IT INSERT MODE?
 133 177c d0 05               BNE OVMODE   ;IF NOT, IT MUST BE OVERSTRIKE 
 134                                       ;MODE.
 135 177e a9 c9               LDA #INSCHR  ;IF SO, GET INSERT GRAPHIC.
 136 1780 18                  CLC          ;
 137 1781 90 02               BCC TVMODE   ;
 138 1783 a9 cf        OVMODE LDA #OVRCHR  ;LOAD A W/OVERSTRIKE CHARACTER.
 139 1785 20 79 09     TVMODE JSR TVPUT    ;PUT MODE GRAPHIC ON SCREEN
 140 1788 a9 02               LDA #2       ;MOVE TWO POSITIONS TO THE
 141 178a 20 5f 09            JSR TVPLUS   ;RIGHT, SO TVPTR POINTS TO
 142                                       ;CENTER OF LINE 3 OF EDIT
 143                                       ;DISPLAY
 144 178d ad 1d 08            LDA ARROW    ;DISPLAY AN UP-ARROW HERE
 145 1790 20 79 09            JSR TVPUT    ;
 146                                       ;
 147 1793 a9 02               LDA #2       ;GO TWO POSITIONS TO THE
 148 1795 20 5f 09            JSR TVPLUS   ;RIGHT, SO TVPTR POINTS TO
 149                                       ;FIELD RESERVED FOR THE
 150                                       ;ADDRESS OF THE CURRENT CHARACTER
 151 1798 ad c6 09            LDA SELECT+1 ;DISPLAY ADDRESS OF CURRENT
 152 179b 20 81 09            JSR VUBYTE   ;CHARACTER
 153 179e ad c5 09            LDA SELECT   ;
 154 17a1 20 81 09            JSR VUBYTE   ; 
 155 17a4 60                  RTS          ;RETURN TO CALLER
 156                   ;********************************************
 157                   ;APPENDIX Cll: ASSEMBLER LISTING OF 
 158                   ;A SIMPLE TEXT EDITOR 
 159                   ;EDITIT SUBROUTINE
 160                   ;SEE CHAPTER 11 OF TOP-DOWN ASSEMBLY LANGUAGE 
 161                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
 162                   ;BY KEN SKIER
 163                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER 
 164                   ;LEXINGTON, MASSACHUSETTS
 165                   ;********************************************
 166                   
 167                   ;********************************************
 168                   ;
 169                   ;VARIABLES
 170                   ;
 171                   ;********************************************
 172                   ;EDIT FUNCTION KEYS
 173                   ;
 174                   ;THE EDITOR RECOGNIZES THE 
 175                   ;FOLLOWING KEYS AS FUNCTION KEYS. 
 176                   ;ASSIGN A FUNCTION TO A KEY 
 177                   ;BY STORING THE DESIRED KEY 
 178                   ;CODE FROM YOUR SYSTEM'S 
 179                   ;KEY HANDLER INTO ONE OF THE 
 180                   ;FOLLOWING DATA BYTES:
 181                   ;
 182 17a5 93           FLSHKY .BYTE $93   ;THIS KEY FLUSHES THE 
 183                                      ;BUFFER OF ANY TEXT. $93 IS 
 184                                      ;THE "CLR" KEY. THUS,"CLR" 
 185                                      ;TO FLUSH THE BUFFER.
 186                   
 187 17a6 94           MODEKY .BYTE $94   ;THIS KEY CAUSES THE EDIT 
 188                                      ;TO CHANGE MODES,FROM INSERT 
 189                                      ;TO OVERSTRIKE, AND VICE VERSA. 
 190                                      ;$94 IS "INS" KEY. THUS,PRESS 
 191                                      ;"INS" TO CHANG EMODES.
 192                   
 193 17a7 1d           NEXTKY .BYTE $1D   ;THIS KEY SELECTS THE NEXT 
 194                                      ;CHARACTER IN THE BUFFER. 
 195                                      ;$1D IS THE RIGHT-ARROW. 
 196                                      ;THUS, PRESS RIGHT-ARROW TO 
 197                                      ;MOVE TO THE RIGHT THROUGH
 198                                      ;THE TEX TBUFFER.
 199                   
 200 17a8 9d           PREVKY .BYTE $9D   ;THIS KEY SELECTS THE PREVIOUS 
 201                                      ;CHARACTER IN THEBUFFER.
 202                                      ;$9D IS THE LEFT-ARROW. 
 203                                      ;THUS, PRESS LEFT-ARROW TO 
 204                                      ;MOVE TO THE LEFT THROUGH 
 205                                      ;THE TEXT BUFFER.
 206                   
 207 17a9 10           PRTKEY .BYTE $10   ;THIS KEY PRINTS THE BUFFER. 
 208                                      ;$10 IS CONTROL-P. THUS, 
 209                                      ;PRESS CONTROL-P TO PRINT 
 210                                      ;THE BUFFER.
 211                   
 212 17aa 14           RUBKEY .BYTE $14   ;THIS KEY RUBS OUT THE 
 213                                      ;CURRENT CHARACTER. THUS, PRESS 
 214                                      ;THE DELETE KEY TO DELETE THE 
 215                                      ;CURRENT CHARACTER.
 216                   
 217 17ab d1           QUITKY .BYTE "Q"   ;TWO QUIT KEYS IN A ROW 
 218                                      ;CAUSE THE EDITOR TO RETURN 
 219                                      ;TO ITS CALLER.
 220                   
 221                   ;OTHER VARIABLES:
 222 17ac 00           TEMPCH .BYTE 0      ;THIS BYTE USED BY EDITIT.
 223                   
 224                   
 225                   ;********************************************
 226                   ;
 227                   ;EDITIT
 228                   ;
 229                   ;********************************************
 230 17ad 20 a8 0a     EDITIT JSR GETKEY  ;GET A KEYSTROKE FROM THE USER.
 231                                      ;
 232 17b0 cd ab 17            CMP QUITKY  ;IS IT THE "QUIT" KEY?
 233 17b3 d0 17               BNE DOKEY   ;IF NOT, DO WHAT THE KEY 
 234                                      ;REQUIRES.
 235                                      ;
 236 17b5 48                  PHA         ;IF IT IS THE "QUIT" KEY, SAVE
 237 17b6 20 a8 0a            JSR GETKEY  ;IT AND GET A NEW KEY FROM
 238                                      ;USER
 239 17b9 cd ab 17            CMP QUITKY  ;IS THIS KEY A "QUIT" KEY, TOO?
 240 17bc d0 04               BNE NOTEND  ;IF NOT, THEN THIS IS NOT THE 
 241                                      ;END OF THE EDIT SESSION.
 242                                      ;END THE EDIT SESSION?
 243 17be 68           ENDEDT PLA         ;POP FIRST "QUIT" KEY FROM 
 244                                      ;STACK.
 245 17bf 68                  PLA         ;POP RETURN ADDRESS TO
 246 17c0 68                  PLA         ;THE EDITOR'S TOP LEVEL.
 247 17c1 60                  RTS         ;RETURN TO THE EDITOR'S CALLER.
 248                                      ;
 249 17c2 8d ac 17     NOTEND STA TEMPCH  ;SAVE THE KEY THAT FOLLOWED 
 250                                      ;THE "QUIT" KEY.
 251 17c5 68                  PLA         ;POP FIRST "QUIT" KEY FROM STACK.
 252 17c6 20 cc 17            JSR DOKEY   ;DO WHAT IT REQUIRES
 253 17c9 ad ac 17            LDA TEMPCH  ;RECOVER THE KEY THAT FOLLOWED
 254                                      ;THE "QUIT" KEY.
 255                   ;
 256                                      ;"DOKEY " DOES WHAT THE KEY 
 257                                      ;IN THE ACCUMULATOR REQUIRES:
 258                                      ;
 259 17cc cd a6 17     DOKEY  CMP MODEKY  ;IS IT THE "CHANGE MODE" KEY?
 260 17cf d0 0b               BNE IFNEXT  ;IF NOT, PERFORM THE NEXT TEST.
 261 17d1 ce e9 16            DEC EDMODE  ;IF SO, CHANGE THE EDITOR'S
 262 17d4 10 05               BPL DOEND   ; MODE.
 263 17d6 a9 01               LDA #1      ;
 264 17d8 8d e9 16            STA EDMODE  ;
 265 17db 60           DOEND  RTS         ;RETURN TO CALLER.
 266                                      ;
 267 17dc cd a7 17     IFNEXT CMP NEXTKY  ;IS IT THE "NEXT" KEY?
 268 17df d0 04               BNE IFPREV  ;IF NOT, PERFORM NEXT TEST.
 269                                      ;
 270 17e1 20 5b 18            JSR NEXTEX  ;IF SO, ADVANCE TO NEXT
 271                                      ;CHARACTER...
 272 17e4 60                  RTS         ;...AND RETURN.
 273                                      ;
 274 17e5 cd a8 17     IFPREV CMP PREVKY  ;IS IT THE "PREVIOUS" KEY?
 275 17e8 d0 04               BNE IFRUB   ;IF NOT, PERFORM NEXT TEST.
 276 17ea 20 69 18            JSR PREVSL  ;IF SO, BACK UP PREVIOUS
 277 17ed 60                  RTS         ;CHARACTER AND RETURN.
 278                                      ;
 279 17ee cd aa 17     IFRUB  CMP RUBKEY  ;IS IT THE "RUBOUT" KEY?
 280 17f1 d0 04               BNE IFPRT   ;IF NOT, PERFORM NEXT TEST.
 281 17f3 20 bf 18            JSR DELETE  ;IF SO, DELETE THE CURRENT 
 282 17f6 60                  RTS         ;CHARACTER AND RETURN.
 283                                      ;
 284 17f7 cd a9 17     IFPRT  CMP PRTKEY  ;IS IT THE "PRINT" KEY?
 285 17fa d0 04               BNE IFFLSH  ;IF NOT, PERFORM NEXT TEST.
 286 17fc 20 a7 18            JSR PRTBUF  ;IF SO, PRINT THE BUFFER...
 287 17ff 60                  RTS         ;...AND RETURN.
 288                                      ;
 289 1800 cd a5 17     IFFLSH CMP FLSHKY  ;IS IT THE "FLUSH" KEY?
 290 1803 d0 04               BNE CHARKY  ;IF NOT, IT MUST BE A CHARACTER
 291                                      ;KEY
 292 1805 20 96 18            JSR FLUSH   ;IF SO, FLUSH THE BUFFER.
 293 1808 60                  RTS         ;AND RETURN.
 294                                      ;
 295                                      ;OK. IT'S NOT AN EDITOR FUNCTION KEY, SO IT
 296                                      ;MUST BE A CHARACTER KEY. DEPENDING ON THE
 297                                      ;CURRENT MODE, WE'LL EITHER INSERT OF OVERSTRIKE
 298                                      ;THE CURRENT CHARACTER
 299                                      ;
 300 1809 ae e9 16     CHARKY LDX EDMODE  ;ARE WE IN OVERSTRIKE MODE?
 301 180c f0 04               BEQ STRIKE  ;IF SO, OVERSTRIKE THE 
 302                                      ;CHARACTER.
 303 180e 20 19 18            JSR INSERT  ;IF NOT, INSERT THE CHARACTER.
 304 1811 60                  RTS         ;RETURN.
 305                                      ;
 306 1812 20 f5 0a     STRIKE JSR PUTSL   ;REPLACE CURRENT CHARACTER
 307                                      ;WITH NEW CHARACTER.
 308                                      ;THE CURRENT CHARACTER.
 309 1815 20 08 10            JSR NEXTSL  ;SELECT NEXT CHARRACTER,
 310 1818 60                  RTS         ;RETURN
 311                                      ;
 312 1819 48           INSERT PHA         ;SAVE THE CHARACTER TO BE 
 313                                      ;INSERTED, WHILE WE MAKE ROOM 
 314                                      ;FOR IT IN THE BUFFER...
 315 181a 20 c8 0c            JSR PUSHSL  ;SAVE THE CURRENT ADDRESS
 316 181d ad 13 08            LDA SA+1    ;SAVE THE BUFFER'S ADDRESS
 317 1820 48                  PHA         ;
 318 1821 ad 12 08            LDA SA      ;
 319 1824 48                  PHA         ;
 320                                      ;
 321 1825 ad 15 08            LDA EA+1    ;SAVE THE BUFFER'S END ADDRESS
 322 1828 48                  PHA         ;
 323 1829 ad 14 08            LDA EA      ;
 324 182c 48                  PHA         ;
 325                                      ;
 326 182d 20 72 0e            JSR SAHERE  ;SET SA EQUAL TO SELECT, SO
 327                                      ;CURRENT LOCATION WILL BE
 328                                      ;START OF THE BLOCK WE'LL
 329                                      ;MOVE
 330                                      ;
 331 1830 20 08 10            JSR NEXTSL  ;ADVANCE TO NEXT CHARACTER
 332                                      ;POSITION IN THE BUFFER.
 333 1833 30 11               BMI ENDINS  ;IF WE'RE AT THE END OF THE 
 334                                      ;BUFFER, WE'LL OVERSTRIKE 
 335                                      ;INSTEAD OF INSERTING.
 336                                      ;
 337 1835 20 dc 16            JSR DAHERE  ;SET DEST EQUAL TO SELECT, 
 338                                      ;DESTINATION OF BLOCK MOVE 
 339                                      ;WILL BE ONE BYTE ABOVE 
 340                                      ;BLOCK'SINITIAL LOCATION
 341                                      ;
 342 1838 ad 14 08            LDA EA      ;DECREMENT END ADDRESS
 343 183b d0 03               BNE DECEA   ;
 344 183d ce 15 08            DEC EA+1    ;
 345 1840 ce 14 08     DECEA  DEC EA      ;
 346                                      ;
 347 1843 20 9d 15     OPENUP JSR MOVEA   ;OPEN UP ONE BYTE OF SPACE 
 348                                      ;AT CURRENT CHARACTER'S 
 349                                      ;LOCATION, BY MOVING TO DEST
 350                                      ;THE BLOCK SPECIFIED BY SA, EA.
 351                                      ;
 352 1846 68           ENDINS PLA         ;RESTORE EA SO IT POINTS
 353 1847 8d 14 08            STA EA      ;TO END OF BUFFER.
 354 184a 68                  PLA         ;
 355 184b 8d 15 08            STA EA+1    ;
 356                                      ;
 357 184e 68                  PLA         ;RESTORE SA SO IT POINTS TO 
 358 184f 8d 12 08            STA SA      ;START OF BUFFER.
 359 1852 68                  PLA         ;
 360 1853 8d 13 08            STA SA+1    ;
 361                                      ;
 362 1856 20 e1 0c            JSR POPSL   ;RESTORE SELECT SO IT POINTS 
 363                                      ;TO CURRENT CHARACTER POSITION.
 364                                      ;
 365 1859 68                  PLA         ;RESTORE NEW CHARACTER TO
 366                                      ;ACCUMLATOR. WE'VE CREATED
 367                                      ;A ONE-BYTE SPACE FOR IT
 368 185a 60                  RTS         ;AND RETURN
 369                   ;********************************************
 370                   ;
 371                   ;NEXTEX
 372                   ;
 373                   ;********************************************
 374 185b 20 5f 0a     NEXTEX JSR GETSL   ;GET CURRENT CHARACTER.
 375 185e c9 ff               CMP #ETX    ;IS IT END OF TEXT CHARACTER?
 376 1860 f0 04               BEQ ANETX   ;IF SO, RETURN TO CALLER, 
 377                                      ;BEARING A NEGATIVE RETURN CODE.
 378                                      ;
 379 1862 20 08 10            JSR NEXTSL  ;IF NOT, SELECT NEXT BYTE IN 
 380                                      ;BUFFER
 381 1865 60                  RTS         ;RETURN PLUS IF WE INCREMENTED
 382                                      ;SELECT; MINUS IF SELECT 
 383                                      ;ALREADY EQUALED EA.
 384                                      ;
 385 1866 a9 ff        ANETX  LDA #$FF    ;SINCE WE ARE ON AN ETX, WE 
 386 1868 60                  RTS         ;WILL RETURN WITH MINUS. WITHOUT
 387                                      ;INCREMENTING SELECT
 388                   ;********************************************
 389                   ;
 390                   ;PREVSL
 391                   ;
 392                   ;********************************************
 393 1869 38           PREVSL SEC          ;PREPARE TO COMPARE.
 394 186a ad 13 08            LDA SA+1     ;IS SELECT IN A HIGHER PAGE
 395 186d cd c6 09            CMP SELECT+1 ;THAN START OF BUFFER?
 396 1870 90 0c               BCC PLOK     ;IF SO, SELECT MAY BE DECREMENTED.
 397 1872 d0 10               BNE NOTOK    ;IF SELECT IS IN A LOWER 
 398                                       ;PAGE THAN SA, IT'S NOT OK.
 399                                       ;
 400                                       ;SELECT IS IN THE SAME PAGE AS SA.
 401 1874 ad 12 08            LDA SA       ;IS SELECT>SA?
 402 1877 cd c5 09            CMP SELECT   ;
 403 187a f0 17               BEQ NODEC    ;IF SELECT EQUALS SA, DON'T 
 404                                       ;DECREMENT SELECT.
 405 187c b0 06               BCS NOTOK    ;IF SELECT<SA, DON'T DECREMENT
 406                                       ;SELECT
 407 187e 20 e2 0a     PLOK   JSR DECSL    ;SELECT>SA, SO WE MAY
 408                                       ;DECREMENT SELECT AND IT
 409                                       ;WILL REMAIN IN THE BUFFER.
 410 1881 a9 00               LDA #0       ;SET A POSITIVE RETURN CODE...
 411 1883 60                  RTS          ;...AND RETURN.
 412                                        ;
 413 1884 ad 12 08     NOTOK  LDA SA       ;SINCE SELECT<SA, IT IS NOT
 414 1887 8d c5 09            STA SELECT   ;EVEN IN THE EDIT BUFFER. SO
 415 188a ad 13 08            LDA SA+1     ;MAKE SELECT LEGAL VALUE, BY SETTING
 416 188d 8d c6 09            STA SELECT+1 ;IT EQUAL TO SA.
 417 1890 a9 00               LDA #0       ;SET A POSITIVE RETURN CODE...
 418 1892 60                  RTS          ;...AND RETURN.
 419                                       ;
 420 1893 a9 ff        NODEC  LDA #$FF     ;SELECT EQUALS SA, SO CHANGE 
 421 1895 60                  RTS          ;NOTHING. RETURN WITH
 422                                       ;NEGATIVE RETURN CODE.
 423                   ;********************************************
 424                   ;
 425                   ;FLUSH
 426                   ;
 427                   ;********************************************
 428 1896 20 25 10     FLUSH  JSR GOTOSA  ;SET SELECT EQUAL TO SA. 
 429 1899 a9 ff        FLOOP  LDA #ETX    ;PUT AN ETX CHARACTER
 430 189b 20 f5 0a            JSR PUTSL   ;INTO THE BUFFER
 431 189e 20 08 10            JSR NEXTSL  ;ADVANCE TO NEXT POSITION IN
 432                                      ;BUFFER.
 433 18a1 10 f6               BPL FLOOP   ;IF WE HAVEN'T REACHED END
 434                                      ;OF BUFFER, PUT AN ETX INTO
 435                                      ;THIS POSITION, TOO.
 436                                      ;
 437 18a3 20 25 10            JSR GOTOSA  ;HAVING FILLED BUFFER WITH
 438                                      ;ETX CHARACTERS, RESET SELECT
 439                                      ;TO BEGINNING OF BUFFER.
 440 18a6 60                  RTS         ;RETURN.
 441                   ;********************************************
 442                   ;
 443                   ;PRTBUF
 444                   ;
 445                   ;********************************************
 446 18a7 20 25 10     PRTBUF JSR GOTOSA  ;SET SELECT TO THE START OF BUFFER.
 447 18aa 20 ca 0b            JSR PRON    ;SELECT PRINTER FOR OUTPUT
 448 18ad 20 5f 0a     PRLOOP JSR GETSL   ;GET THE CURRENT CHARACTER.
 449 18b0 c9 ff               CMP #ETX    ;IS IT ETX?
 450 18b2 f0 08               BEQ ENDPRT  ;IF SO, WE'RE DONE.
 451 18b4 20 f6 0b            JSR PRCHR   ;IF NOT, PRINT IT.
 452 18b7 20 08 10            JSR NEXTSL  ;SELECT NEXT CHARACTER
 453 18ba 10 f1               BPL PRLOOP  ;IF WE HAVEN'T REACHED THE
 454                                      ;END OF THE BUFFER, HANDLE
 455                                      ;THE CURRENT CHARACTER AS BEFORE
 456 18bc 4c d0 0b     ENDPRT JMP PROFF   ;HAVING REACHED END OF MESSAGE
 457                                      ;OR END OF BUFFER, RETURN TO
 458                                      ;CALLER OF EDITIT, DESELECTING
 459                                      ;THE PRINTER AS WE DONE.
 460                   ;********************************************
 461                   ;
 462                   ;DELETE
 463                   ;
 464                   ;********************************************
 465 18bf 20 c8 0c     DELETE JSR PUSHSL  ;SAVE CURRENT ADDRESS
 466 18c2 ad 13 08            LDA SA+1    ;SAVE BUFFER'S START ADDRESS.
 467 18c5 48                  PHA         ;
 468 18c6 ad 12 08            LDA SA      ;
 469 18c9 48                  PHA         ;
 470                                      ;
 471 18ca 20 dc 16            JSR DAHERE  ;SET DEST EQUAL SELECT, 
 472                                      ;BECAUSE WE'LL MOVE A BLOCK OF 
 473                                      ;TEXT DOWN TO HERE, TO ;CLOSE UP 
 474                                      ;THE BUFFER AT THE CURRENT
 475                                      ;CHARACTER.
 476 18cd 20 08 10            JSR NEXTSL  ;ADVANCE BY ONE BYTE THROUGH
 477                                      ;BUFFER, IF POSSIBLE.
 478 18d0 20 72 0e            JSR SAHERE  ;SET SA EQUAL TO SELECT, BECAUSE 
 479                                      ;THIS IS THE START OF THE BLOCK
 480                                      ;WE'LL MOVE DOWN.
 481                                      ;NOTE: THE END ADDRESS OF
 482                                      ;THE BLOCK IS THE END ADDRESS
 483                                      ;OF THE TEXT BUFFER.)
 484 18d3 20 9d 15            JSR MOVEA   ;MOVE BLOCK SPECIFIED BY 
 485                                      ;SA, EA, AND DEST.
 486                                      ;
 487 18d6 68                  PLA         ;RESTORE INITIAL SA (WHICH
 488 18d7 8d 12 08            STA SA      ;IS THE START ADDRESS OF THE
 489 18da 68                  PLA         ;TEXT BUFFER, NOT OF THE BLOCK
 490 18db 8d 13 08            STA SA+1    ;WE JUST MOVED).
 491                                      ;
 492 18de 20 e1 0c            JSR POPSL   ;RESTORE CURRENT ADDRESS
 493 18e1 60                  RTS         ;RETURN TO CALLER.
 494                   ;********************************************
 495                   ;
 496                   ; ADDED CODE
 497                   ;
 498                   ;********************************************
 499                   
 500                   ;********************************************
 501                   ;
 502                   ; FILL TEXT BUFFER WITH START OF TEXT AND
 503                   ; END OF TEXT MARKERS
 504                   ;
 505                   ;********************************************
 506                   INITBUF 
 507 18e2 a9 00                LDA #<FRERAM
 508 18e4 85 fb                STA PUTPTR
 509 18e6 a9 c1                LDA #>FRERAM
 510 18e8 85 fc                STA PUTPTR+1
 511                   ;
 512 18ea a0 00               LDY #$00
 513 18ec a9 7f               LDA #TEX
 514 18ee 91 fb               STA (PUTPTR),Y
 515 18f0 c8                  INY
 516                   ;
 517 18f1 a9 ff               LDA #ETX
 518 18f3 91 fb        IL     STA (PUTPTR),Y
 519 18f5 c8                  INY
 520 18f6 d0 fb               BNE IL
 521                   ;
 522 18f8 60                  RTS      
 523                   ;********************************************
 524                   ;
 525                   ;
 526                   ;
 527                   ;********************************************
 529                   
  98                   .endif
  99                   ;****************************
 100                   ; Extending the Visible Monitor
 101                   ;****************************
 102                   .ifne CHAP12
 103                   .include "CHAPTER12.ASM"
   1                   ;********************************************
   2                   ;VISIBLE MONITOR EXTENSIONS
   3                   ;
   4                   ;APPENDIX C12: ASSEMBLER LISTING OF
   5                   ;VISIBLE MONITOR EXTENSIONS
   6                   ;SEE CHAPTER 12 OF TOP-DOWN ASSEMBLY LANGUAGE
   7                   ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20
   8                   ;BY KEN SKIER
   9                   ;COPYRIGHT (C) 1984 BY KENNETH SKIER
  10                   ;LEXINGTON, MASSACHUSETTS;
  11                   ;********************************************
  12                   
  13                   ;********************************************
  14                   ;
  15                   ;EXTENSIONS TO THE VISIBLE MONITOR
  16                   ;
  17                   ; P TOGGLE PRINTER ON AND OFF
  18                   ; U TOGGLE USER DEVICE ON AND OFF
  19                   ; H EXIT DUMP (TYPE DEPENDS OF STATE OF PRINTER)
  20                   ; M MOVE MEMORY
  21                   ; ? DISASSMBLER (TYPE DEPENDS OF STATE OF PRINTER)
  22                   ; T SIMPLE TEXT EDITOR
  23                   ;
  24                   ;********************************************
  25 18f9 c9 d0        EXTEND CMP #"P"    ;Is it the P key?
  26 18fb d0 09               BNE IFU     ;If not, perform the next test.
  27 18fd ad b7 0b            LDA PRINTR  ;If so, toggle the printer
  28 1900 49 ff               EOR #$FF    ;flag
  29 1902 8d b7 0b            STA PRINTR  ;
  30 1905 60                  RTS         ;and return to caller.
  31                   ;
  32 1906 c9 d5        IFU    CMP #"U"    ;Is it the "U" key?
  33 1908 d0 06               BNE IFH     ;If not, perform the next test.
  34 190a ad b8 0b            LDA USER    ;If so, toggle the user-
  35 190d 49 ff               EOR #$FF    ;PROVIDED output FLAG...
  36 190f 60                  RTS         ;AND RETURN
  37                   ;
  38 1910 c9 c8        IFH    CMP #"H"    ;Is it the "H" key?
  39 1912 d0 0d               BNE IFM     ;If not, perform the next test.
  40 1914 ad b7 0b            LDA PRINTR  ;Is the printer selected?
  41 1917 d0 04               BNE NEXTPD  ;If so, print a hexdump.
  42 1919 20 fd 0c            JSR TVDUMP  ;If not, dump to screen...
  43 191c 60                  RTS         ;and return.
  44                   ;
  45 191d 20 51 0d     NEXTPD JSR PRDUMP  ;Print a hexdump...
  46 1920 60                  RTS         ;...and return.
  47                   ;
  48 1921 c9 cd        IFM    CMP #"M"    ;Is it the "M" key?
  49 1923 d0 04               BNE IFDIS   ;If not, perform the next test.
  50 1925 20 81 15            JSR MOVER   ;If so, LET USER SPECIFY AND
  51 1928 60                  RTS         ;MOVE A BLOCK OF MEMORY
  52                   ;
  53 1929 c9 3f        IFDIS  CMP #"?"    ;Is it the "?" key?
  54 192b d0 0d               BNE IFT     ;If not, perform the next test.
  55 192d ad b7 0b            LDA PRINTR  ;Is the printer selected?
  56 1930 d0 04               BNE NEXTDS  ;If so, print a disassembly.
  57 1932 20 3b 10            JSR TVDIS   ;If not, DISASSEMBLE TO THE
  58 1935 60                  RTS         ;SCREEN AND RETURN
  59                   ;
  60 1936 20 58 10     NEXTDS JSR PRDIS   ;Print a disassembly...
  61 1939 60                  RTS         ;and return.
  62                   ;
  63 193a c9 d4        IFT    CMP #"T"     ;Is it the "T" key?
  64 193c d0 04               BNE EXEXT    ;If not, return.
  65 193e 20 ea 16            JSR EDITOR   ;If so, call the SIMPLE
  66 1941 60                  RTS          ;TEXT EDITOR and return.
  67                   ;
  68 1942 60           EXEXT  RTS          ;EXTbiND THE VISIBLE MONITOR
  69                                       ;EVEN FURTHER BY REPLACING
  70                                       ;THIS RTS' WITH A JMF" TO
  71                                       ;MORE TEST-AND-BRANCH CODE.
  72                   ;********************************************
  73                   ;
  74                   ;
  75                   ;
  76                   ;********************************************
  78                   
 104                   .endif
 105                   ;****************************
 107                   
