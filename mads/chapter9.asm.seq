;********************************************;A TABLE-DRIVEN DISASSMBLER;;APPENDIX C6: ASSEMBLER LISTING OF;TABLE-DRIVEN DISASSEMBLER;TOP-LEVEL AND UTILITY SUBROUTINES;SEE CHAPTER 9 OF TOP-DOWN ASSEMBLY LANGUAGE;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20;BY KEN SKIER;COPYRIGHT (C) 1984 BY KENNETH SKIER;LEXINGTON, MASSACHUSETTS;;********************************************;********************************************;;CONSTANTS;;********************************************;********************************************;;VARIABLES;;********************************************DISLNS .BYTE 5    ;NUMBER OF LINES TO BE                  ;DISASSEMBLED BY TV.DIS.                  ;LINUM  .BYTE 0    ;DATA CELL: USED BY TV.DIS.LETTER .BYTE 0    ;COUNTS LETTERS PRINTED IN                  ;A MNEMONIC. USED BY MNEMON.                  ;TEMPD  .BYTE 0    ;DATA CELL USED BY MNEMON.                  ;SUBPTR .WORD 0    ;POINTER TO A SUBROUTINE.                  ;SET, USED BY MODE.X                  ;OPBYTS .BYTE 0    ;DATA CELL: USED BY FINISH.                  ;OPCHRS .BYTE 0    ;DATA CELL: USED BY FINISH.                  ;ADRCOL .BYTE 11   ;STARTING COLUMN FOR ADDRESS                  ;FIELD.;********************************************;;TV-DISASSEMBLER;;********************************************TVDIS  JSR TVTON   ;SELECT SCREEN FOR OUTPUT.       LDA DISLNS  ;INITIALIZE LINE COUNTER WITH       STA LINUM   ;# OF LINES TO DISASSEMBLE.                   ;       LDA #$FF    ;SET END ADDRESS TO $FFFF,       STA EA      ;SO NEXTSL WILL ALWAYS       STA EA+1    ;INCREMENT SELECT POINTER.       JSR CRLF    ;ADVANCE TO A NEW LINE.                   ;TVLOOP JSR DSLINE  ;DISASSEMBLE ONE LINE.       DEC LINUM   ;DONE LAST LINE YET?       BNE TVLOOP  ;IF NOT, DO NEXT ONE.       RTS         ;IF SO, RETURN.;********************************************;;PRINTING DISASSEMBLER;;********************************************PRDIS  JSR PROFF   ;DE-SELECT PRINTER       JSR TVTON   ;SELECT SCREEN FOR OUTPUT.       JSR PRINTX  ;DISPLAY TITLE.       .BYTE TEX,CR,LF       .BYTE ' PRINTING DISASSEMBLER.'        .BYTE CR,LF,ETX                   ;        JSR SETADI  ;TEST CODE       ;JSR SETADS  ;LET USER SET START, END                   ;ADDRESSES OF MEMORY TO BE                   ;DISASSEMBLED.       JSR PRON    ;SELECT PRINTER FOR OUTPUT.       JSR PRINTX  ;      .BYTE TEX,CR,LF      .BYTE 'DISASSEMBLING'      .BYTE ETX                   ;       JSR RANGE   ;PRINT RANGE OF MEMORY TO                   ;BE DISASSEMBLED.                   ;       JSR GOTOSA  ;MAKE SELECT POINT TO START                   ;OF BLOCK.                   ;       JSR CRLF    ;ADVANCE TO A NEW LINE.DILOOP JSR DSLINE  ;DISASSEMBLE ONE LINE.       BPL DILOOP  ;IF IT WASN'T THE LAST LINE,                   ;DISASSEMBLE THE NEXT ONE.                   ;       JSR PROFF   ;DE-SELECT PRINTER FOR OUTPUT.                   ;       RTS         ;RETURN TO CALLER.;********************************************;;DISASSEMBLE ONE LINE;;********************************************DSLINE JSR GETSL   ;GET CURRENTLY-SELECTED BYTE.       PHA         ;SAVE IT ON STACK.       JSR MNEMON  ;PRINT MNEMONIC REPRESENTED                   ;BY THAT OPCODE.       JSR SPACEO  ;SPACE ONCE.       PLA         ;RESTORE OPCODE.       JSR OPERND  ;PRINT OPERAND REQUIRED BY                   ;THAT OPCODE.       JSR FINISH  ;FINISH THE LINE BY PRINTING                   ;FIELDS 3-6. FINISH LEAVES                   ;SELECT POINTING TO LAST                   ;BYTE OF INSTRUCTION.                   ;       JSR NEXTSL  ;SELECT NEXT BYTE, IF                   ;SELECT<EA.       RTS         ;RETURN W/RETURNCODE FROM                   ;NEXTSL. SELECT POINTS TO                   ;NEXT OPCODE, OR SELECT                   ;EQUALS EA.;********************************************;;PRINT MNEMONIC;;********************************************MNEMON LDX #3       ;WE'LL PRINT THREE LETTERS.       STX LETTER   ;       TAX          ;PREPARE TO USE OPCODE AS AN                    ;INDEX.                    ;       LDA MCODES,X ;LOOK UP MNEMONIC CODE FOR                    ;THAT OPCODE. MCODES IS                    ;TABLE OF MNEMONIC CODES.                    ;       TAX          ;PREPARE TO USE THAT MNEMONIC                    ;CODE AS AN INDEX.MNLOOP LDA MNAMES,X ;GET A MNEMONIC CHARACTER.                    ;(MNAMES IS A LIST OF                    ;                    ;MNEMONIC NAMES.)       STX TEMPD    ;SAVE X-REGISTER, SINCE                    ;PRINTING MAY CHANGE X       JSR PRCHR    ;PRINT THE MNEMONIC CHARACTER.       LDX TEMPD    ;RESTORE X.       INX          ;ADJUST INDEX FOR NEXT LETTER.       DEC LETTER   ;PRINTED 3 LETTERS YET?       BNE MNLOOP   ;IF NOT, PRINT NEXT ONE.       RTS          ;IF SO, RETURN TO CALLER.;********************************************;;PRINT OPERAND;;********************************************OPERND TAX         ;LOOK UP ADDRESSING MODE       LDA MODES,X ;CODE FOR THIS OPCODE.                   ;       TAX         ;X NOW INDICATES ADDRESSING                   ;MODE.                   ;       JSR MODEX   ;HANDLE THAT ADDRESSING MODE.       RTS         ;RETURN TO CALLER.;********************************************;;HANDLE ADDRESSING MODE 'X';;********************************************MODEX  LDA SUBS,X   ;GET LOW BYTE OF Xth POINTER       STA SUBPTR   ;IN TABLE OF SUBROUTINE                    ;POINTERS.       INX          ;ADJUST INDEX FOR NEXT BYTE.       LDA SUBS,X   ;GET HIGH BYTE OF POINTER.       STA SUBPTR+1 ;       JMP (SUBPTR) ;JUMP TO SUBROUTINE SPECIFIED                    ;BY SUBROUTINE POINTER.                    ;THAT SUBROUTINE WILL RETURN                    ;TO THE CALLER OF MODE.X,                    ;NOT TO MODE.X ITSELF.;********************************************;;DISASSEMBLER UTILITIES;;********************************************;********************************************;;PRINT ONE-BYTE OPERAND;;********************************************ONEBYT JSR INCSL   ;ADVANCE TO BYTE FOLLOWING                   ;OPCODE.       JSR DUMPSL  ;DUMP THAT BYTE.       RTS         ;RETURN TO CALLER.;********************************************;;PRINT TWO-BYTE OPERAND:;;********************************************TWOBYT JSR INCSL   ;ADVANCE TO FIRST BYTE OF                   ;OPERAND.       JSR GETSL   ;LOAD THAT BYTE INTO ACC.       PHA         ;SAVE IT.       JSR INCSL   ;ADVANCE TO 2ND BYTE OF                    ;OPERAND.       JSR DUMPSL  ;DUMP IT       PLA         ;RESTORE FIRST BYTE TO THE ACC.       JSR PRBYT   ;DUMP IT       RTS         ;RETURN TO CALLER.;********************************************;;PRINT LEFT, RIGHT PARENTHESIS;;********************************************LPAREN LDA #$28    ;PRINT LEFT PAREN.       BNE SENDIT  ;                   ;RPAREN LDA #$29    ;PRINT RIGHT PAREN.                   ;SENDIT JSR PRCHR   ;       RTS         ;;********************************************;;PRINT A COMMA AND AN 'X';;********************************************XINDEX LDA #$2C       JSR PRCHR   ;PRINT A COMMA.       LDA #'x'       JSR PRCHR   ;PRINT AN 'X'       RTS;********************************************;;PRINT A COMMA AND AN 'Y';;********************************************YINDEX LDA #$2C       JSR PRCHR   ;PRINT A COMMA.       LDA #'y'       JSR PRCHR   ;PRINT AN 'Y'       RTS;********************************************;;FINISH THE LINE;;********************************************                   ;NOTE: EVERY ADDRESSING MODE                   ;      SUBROUTINE MUST END BY                   ;      SETTING X EQUAL TO THE                   ;      NUMBER OF BYTES IN THE                   ;      OPERAND, AND ACC EQUAL                   ;      TO THE NUMBER OF                   ;      CHARACTERS IN OPERAND.FINISH STA OPCHRS  ;SAVE THE LENGTH OF THE       STX OPBYTS  ;OPERAND, IN CHARACTERS AND                   ;IN BYTES. 0 MEANS NO                   ;OPERAND.                   ;       DEX         ;IF NECESSARY, DECREMENT THE                   ;SELECT POINTER SO IT POINTS       BMI SELOK   ;TO THE OPCODE.LOOPS1 JSR DECSL   ;       DEX         ;       BPL LOOPS1  ;                   ;                   ;NOW SELECT POINTS TO OPCODE.                   ;SELOK  PHP         ;SAVE CALLER'S DECIMAL FLAG.       CLD         ;PREPARE FOR BINARY ADDITION.                   ;       SEC         ;SPACE OVER TO THE COLUMN       LDA ADRCOL  ;FOR THE ADDRESS FIELD:       SBC #4      ;OPERAND FIELD STARTED IN                   ;COLUMN 4...       SBC OPCHRS  ;AND INCLUDES OPCHRS                   ;CHARACTERS.       PLP         ;RESTORE CALLER'S DECIMAL FLAG       TAX         ;       JSR SPACES  ;PRINT ENOUGH SPACES TO                   ;REACH ADDRESS COLUMN.                   ;       JSR PRADR   ;PRINT ADDRESS OF OPCODE.       JSR SPACEO  ;SPACE AFTER OPCODE'S ADDRESS.                   ;LOOPS2 JSR DUMPSL  ;DUMP SELECTED BYTE.                   ;       LDA TVCOLS  ;IS SCREEN < 24 COLUMNS WIDE?       SEC         ;       CMP #24     ;       BCC DUMPED  ;IF SO, DON'T SPACE AGAIN.                   ;                   ;SCREEN IS > 24 COLUMNS WIDE.                   ;       JSR SPACEO  ;SO SPACE AFTER DUMPING BYTE.                   ;                   ;WE'VE DUMPED SELECTED BYTE.DUMPED JSR INCSL   ;SELECT NEXT BYTE.       DEC OPBYTS  ;DUMPED LAST BYTE IN                   ;INSTRUCTION?       BPL LOOPS2  ;IF NOT, DUMP NEXT BYTE.       JSR DECSL   ;BACK UP SELECT, SO IT POINTS                   ;TO LAST BYTE IN OPERAND.                   ;                   ;IF SO, GO TO A NEW LINE:                   ;FINEND JSR CRLF    ;HAVING DISASSEMBLED ONE LINE,                   ;GO TO A NEW LINE.       RTS         ;RETURN TO CALLER.;********************************************;;ADDRESSING MODE SUBROUTINES;;********************************************;********************************************;;ABSOLUTE MODE;;********************************************ABSLUT JSR TWOBYT ;PRINT A TWO-BYTE OPERAND       LDX #2     ;OPERAND HAS TWO BYTES...       LDA #4     ;...AND FOUR CHARACTERS.       RTS        ;RETURN TO CALLER.        ;********************************************;;ABSOLUTE,X MODE;;********************************************ABSX  JSR ABSLUT      JSR XINDEX   ;PRINT A COMMA AND AN 'X'      LDX #2       ;OPERAND HAS 2 BYTES...      LDA #6       ;...AND SIX CHARACTERS.      RTS          ;RETURN TO CALLER.;********************************************;;ABSOLUTE,Y MODE;;********************************************ABSY  JSR ABSLUT      JSR YINDEX   ;PRINT A COMMA AND AN 'Y'      LDX #2       ;OPERAND HAS 2 BYTES...      LDA #6       ;...AND SIX CHARACTERS.      RTS          ;RETURN TO CALLER.;********************************************;;ACCUMULATOR MODE;;********************************************ACC    LDA #'A'    ;PRINT THE LETTER 'A'.       JSR PRCHR       LDX #0      ;OPERAND HAS NO BYTES.       LDA #1      ;...AND ONE CHARACTER       RTS         ;RETURUN TO CALLER;********************************************;;IMPLIED MODE;;********************************************IMPLID LDX #0      ;OPERAND HAS NO BYTES...       LDA #0      ;...AND NO CHARACTERS.       RTS;********************************************;;IMMEDIATE MODE;;********************************************IMMEDT LDA #'#'    ;PRINT A '#' CHARACTER.       JSR PRCHR   ;                   ;       LDA #'$'    ;PRINT A DOLLAR SIGN TO       JSR PRCHR   ;INDICATE HEXADECIMAL       JSR ONEBYT  ;PRINT ONE-BYTE OPERAND IN                   ;HEXADECIMAL FORMAT.       LDX #1      ;OPERAND HAS ONE BYTE...       LDA #4      ;...AND FOUR CHARACTERS.       RTS         ;RETURN TO CALLER.;********************************************;;INDIRECT MODE;;********************************************INDRCT JSR LPAREN  ;PRINT LEFT PARENTHESIS.       JSR ABSLUT  ;PRINT TWO-BYTE OPERAND.       JSR RPAREN  ;PRINT RIGHT PARENTHESIS.       LDA #6      ;A HOLDS NUMBER OF CHARACTERS                   ;IN OPERAND.       LDX #2      ;X HOLDS NUMBER OF BYTES IN                   ;OPERAND.       RTS         ;RETURN TO CALLER.;********************************************;;INDIRECT,X MODE;;********************************************INDX  JSR LPAREN   ;PRINT A ZERO PAGE ADDRESS,      JSR ZEROX    ;A COMMA, AND THE LETTER 'X'.                   ;      JSR RPAREN   ;      LDX #1       ;ONE BYTE IN OPERAND.      LDA #6       ;6 CHARACTERS IN OPERAND.      RTS          ;;********************************************;;INDIRECT,Y MODE;;********************************************INDY  JSR LPAREN   ;      JSR ZEROPG   ;PRINT A ZERO PAGE ADDRESS,      JSR RPAREN   ;      JSR YINDEX   ;PRINT A COMMA AND A 'Y'      LDX #1       ;OPERAND HAS 1 BYTE...      LDA #6       ;...AND 6 CHARACTERS.      RTS          ;;********************************************;;RELATIVE MODE;;********************************************RELATV JSR INCSL    ;SELECT NEXT BYTE.       JSR PUSHSL   ;SAVE SELECT POINTER ON STACK.       JSR GETSL    ;GET OPERAND BYTE.       PHA          ;SAVE IT ON STACK.       JSR INCSL    ;INCREMENT SELECT POINTER                    ;SO IT POINTS TO NEXT OPCODE.                    ;(RELATIVE BRANCHES ARE                    ;RELATIVE TO NEXT OPCODE.)       PLA          ;RESTORE OPERAND BYTE TO ACC.       CMP #0       ;IS IT PLUS OR MINUS?       BPL FORWRD   ;IF PLUS, IT MEANS A FORWARD                    ;BRANCH.                    ;                    ;OPERAND IS MINUS, SO WE'LL                    ;BRANCH BACKWARD.       DEC SELECT+1 ;BRANCHING BACKWARD IS LIKE                    ;BRANCHING FORWARD FROM ONE                    ;PAGE LOWER IN MEMORY.FORWRD PHP          ;       CLD          ;SAVE CALLER'S DECIMAL FLAG.                    ;CLEAR DECIMAL MODE, FOR                    ;BINARY ADDITION.       CLC          ;PREPARE TO ADD.       ADC SELECT   ;ADD OPERAND BYTE TO SELECT.       BCC RELEND   ;       INC SELECT+1 ;RELEND STA SELECT   ;NOW SELECT POINTS TO ADDRESS                    ;SPECIFIED BY RELATIVE                    ;BRANCH INSTRUCTION.       PLP          ;RESTORE CALLER'S DECIMAL                    ;FLAG.       JSR PRADR    ;PRINT ADDRESS SPECIFIED                    ;BY INSTRUCTION.       JSR POPSL    ;MAKE SELECT POINT TO                    ;ADDRESS OF OPERAND.       LDX #1       ;OPERAND HAD ONE BYTE...       LDA #4       ;AND FOUR CHARACTERS.       RTS          ;RETURN TO CALLER.;********************************************;;ZERO PAGE MODE;;********************************************ZEROPG JSR ONEBYT  ;PRINT ONE-BYTE OPERAND.       LDX #1      ;OPERAND HAS ONE BYTE...       LDA #2      ;AND TWO CHARACTERS.       RTS;********************************************;;ZERO PAGE, X MODE;;********************************************ZEROX  JSR ZEROPG  ;PRINT THE ZERO PAGE ADDRESS.       JSR XINDEX  ;PRINT A COMMA AND AN 'X'.       LDX #1      ;OPERAND HAS 1 BYTE...       LDA #4      ;...AND FOUR CHARACTERS.       RTS         ;RETURN TO CALLER.;********************************************;;ZERO PAGE, Y MODE;;********************************************ZEROY  JSR ZEROPG  ;PRINT THE ZERO PAGE ADDRESS.       JSR YINDEX  ;PRINT A COMMA AND AN 'X'.       LDX #1      ;OPERAND HAS 1 BYTE...       LDA #4      ;...AND FOUR CHARACTERS.       RTS         ;RETURN TO CALLER.;********************************************;;A PSEUDO-ADDRESSING MODE;FOR EMBEDDED TEXT: TEXT MODE.;;********************************************;********************************************;;THE PSEUDO-OPCODE TEX <$7F> BEGINS ANY;STRING OF TEXT AND PRINT CONTROL CHARACTERS.;THE PSEUDO-TEXT CHARACTER ETX <*FF> ENDS ANY;SUCH STRING. TEX HAS A PSEUDO-ADDRESSING;MODE: TEXT MODE. IN TEXT MODE, WE PRINT THE;STRING AND RETURN, WITHOUT DUMPING THE LINE;IN HEX. THE STRING MAY BE OF ANY LENGTH.;;********************************************TXMODE PLA          ;POP RETURN ADDRESS TO       PLA          ;OPERND.                    ;       PLA          ;POP REJURN ADDRESS TO       PLA          ;DSLINE.                    ;                    ;NOW DSLINE'S CALLER IS ON                    ;THE STACK.                    ;       JSR NEXTSL   ;ADVANCE PAST TEX PSEUDO-OP.       BMI TXEXIT   ;RETURN IF REACHED EA.       JSR GETSL    ;GET THE CHARACTER.       CMP #ETX     ;IT END OF TEXT?       BEQ TXEXIT   ;IF SO, STRING ENDED.       JSR PRCHR    ;IF NOT, PRINT CHARACTER.       CLC          ;BRANCH BACK TO GET NEXT       BCC TXMODE+4 ;CHARACTER.TXEXIT JSR CRLF     ;ADVANCE TO A NEW LINE.       JSR NEXTSL   ;ADVANCE TO NEXT OPCODE.       RTS          ;RETURN TO CALLER OF DSLINE.;********************************************;;TABLE OF ADDRESSING MODE SUBROUTINES;;********************************************SUBS .WORD IMPLID  ;ADDRESSING MODE 0 IS INVALID,                   ;HENCE IMPLIED.     .WORD ACC     .WORD IMMEDT     .WORD ZEROPG     .WORD ZEROX     .WORD ZEROY     .WORD ABSLUT     .WORD ABSX     .WORD ABSY     .WORD IMPLID     .WORD RELATV     .WORD INDX     .WORD INDY     .WORD INDRCT     .WORD TXMODE;********************************************;;LIST OF MNEMONICS;;********************************************MNAMES .BYTE TEX  ;SINCE THIS TABLE IS A                  ;STRING OF CHARACTERS, START                  ;IT WITH THE TEX PSEUDO-OP.       .BYTE 'BAD'       .BYTE 'ADC'       .BYTE 'AND'       .BYTE 'ASL'       .BYTE 'BCC'       .BYTE 'BCS'       .BYTE 'BEQ'       .BYTE 'BIT'       .BYTE 'BMI'       .BYTE 'BNE'       .BYTE 'BPL'       .BYTE 'BRK'       .BYTE 'BVC'       .BYTE 'BVS'       .BYTE 'CLC'       .BYTE 'CLD'       .BYTE 'CLI'       .BYTE 'CLV'       .BYTE 'CMP'       .BYTE 'CPX'       .BYTE 'CPY'       .BYTE 'DEC'       .BYTE 'DEX'       .BYTE 'DEY'       .BYTE 'EOR'       .BYTE 'INC'       .BYTE 'INX'       .BYTE 'INY'       .BYTE 'JMP'       .BYTE 'JSR'       .BYTE 'LDA'       .BYTE 'LDX'       .BYTE 'LDY'       .BYTE 'LSR'       .BYTE 'NOP'       .BYTE 'ORA'       .BYTE 'PHA'       .BYTE 'PHP'       .BYTE 'PLA'       .BYTE 'PLP'       .BYTE 'ROL'       .BYTE 'ROR'       .BYTE 'RTI'       .BYTE 'RTS'       .BYTE 'SBC'       .BYTE 'SEC'       .BYTE 'SED'       .BYTE 'SEI'       .BYTE 'STA'       .BYTE 'STX'       .BYTE 'STY'       .BYTE 'TAX'       .BYTE 'TAY'       .BYTE 'TSX'       .BYTE 'TXA'       .BYTE 'TXS'       .BYTE 'TYA'       .BYTE 'TEX'.BYTE ETX          ;SINCE THIS IS THE END OF A                   ;STRING OF CHARACTERS, USE                   ;ETX TO INDICATE END OF TEXT.;********************************************;;TABLE OF MNEMONIC CODES;; A MNEMONICS CODE IS ITS OFFSET INTO; MNAMES, THE LIST OF MNEONIC NAMES.;;********************************************MCODES .BYTE $22,$6A,  1,  1,  1,$6A,$0A,  1       .BYTE $70,$6A,$0A,  1,  1,$6A,$0A,  1       .BYTE $1F,$6A,  1,  1,  1,$6A,$0A,  1       .BYTE $2B,$6A,  1,  1,  1,$6A,$0A,  1       .BYTE $58,  7,  1,  1,$16,  7,$79,  1       .BYTE $76,  7,$79,  1,$16,  7,$79,  1       .BYTE $19,  7,  1,  1,  1,  7,$79,  1       .BYTE $88,  7,  1,  1,  1,  7,$79,  1       .BYTE $7F,$49,  1,  1,  1,$49,$64,  1       .BYTE $6D,$49,$64,  1,$55,$49,$64,  1       .BYTE $25,$49,  1,  1,  1,$49,$64,  1       .BYTE $31,$49,  1,  1,  1,$49,$64,  1       .BYTE $82,  4,  1,  1,  1,  4,$7C,  1       .BYTE $73,  4,$7C,  1,$55,  4,$7C,  1       .BYTE $28,  4,  1,  1,  1,  4,$7C,  1       .BYTE $8E,  4,  1,  1,  1,  4,$7C,$AC       .BYTE   1,$91,  1,  1,$97,$91,$94,  1       .BYTE $46,  1,$A3,  1,$97,$91,$94,  1       .BYTE $0D,$91,  1,  1,$97,$91,$94,  1       .BYTE $A9,$91,$A3,  1,  1,$91,  1,  1       .BYTE $61,$5B,$5E,  1,$61,$5B,$5E,  1       .BYTE $9D,$5B,$9A,  1,$61,$5B,$5E,  1       .BYTE $10,$5B,  1,  1,$61,$5B,$5E,  1       .BYTE $34,$5B,$9E,  1,$61,$5B,$5E,  1       .BYTE $3D,$37,  1,  1,$3D,$37,$40,  1       .BYTE $52,$37,$43,  1,$3D,$37,$40,  1       .BYTE $1C,$37,  1,  1,  1,$37,$40,  1       .BYTE $2E,$37,  1,  1,  1,$37,$40,  1       .BYTE $3A,$85,  1,  1,$3A,$B5,$4C,  1       .BYTE $4F,$85,$67,  1,$3A,$85,$4C,  1       .BYTE $13,$85,  1,  1,  1,$85,$4C,  1       .BYTE $8B,$85,  1,  1,  1,$85,$4C,  1       ;********************************************;;TABLE OF ADDRESSING MODE CODES;;AN ADDRESSING MODE'S CODE IS IT'S OFFSET;INTO SUBS, THE TABLE OF ADDRESSING MODE;SUBROUTINES.;;********************************************MODES .BYTE 18,22, 0, 0, 0, 6, 6, 0      .BYTE 18, 4, 2, 0, 0,12,12, 0      .BYTE 20,24, 0, 0, 0,14,14, 0      .BYTE 18,16, 0, 0, 0,22,22, 0      .BYTE 12,22, 0, 0, 6, 6, 6, 0      .BYTE 18, 4, 2, 0,12,12,12, 0      .BYTE 20,24, 0, 0, 0, 8, 8, 0      .BYTE 18,16, 0, 0, 0,14,14, 0      .BYTE 18,22, 0, 0, 0, 6, 6, 0      .BYTE 18,12, 2, 0,12,12,12, 0      .BYTE 20,24, 0, 0, 0, 8, 8, 0      .BYTE 18,16, 0, 0, 0,14,14, 0      .BYTE 18,22, 0, 0, 0, 6, 6, 0      .BYTE 18, 4, 2, 0,26,12,12, 0      .BYTE 20,24, 0, 0, 0, 8, 8, 0      .BYTE 18,16, 0, 0, 0, 4,14,28      .BYTE 0 ,22, 0, 0, 6, 6, 6, 0      .BYTE 18, 0,18, 0,12,12,12, 0      .BYTE 20,24, 0, 0, 8, 8,10, 0      .BYTE 18,16,18, 0, 0,14, 0, 0      .BYTE  4,22, 4, 0, 6, 6, 6, 0      .BYTE 18, 4,18, 0,12,12,12, 0      .BYTE 20,24, 0, 0, 8, 8,10, 0      .BYTE 20,16,18, 0,14,14,16, 0      .BYTE  4,22, 0, 0, 6, 6, 6, 0      .BYTE 18, 4,18, 0,12,12,12, 0      .BYTE 20,24, 0, 0, 0, 8, 8, 0      .BYTE 18,16, 0, 0, 0,14,14, 0      .BYTE  4,22, 0, 0, 6, 6, 6, 0      .BYTE 18, 4,18, 0,12,12,12, 0      .BYTE 20,24, 0, 0, 0, 8, 8, 0      .BYTE 18,16, 0, 0, 0,14,14, 0;********************************************;;;;********************************************;********************************************;;SET STARTING ADDRESS, ENDING ADDRESS;TEST MODE;;********************************************SETADI JSR TVTON    ;SELECT TVT AS AN OUTPUT DEVICE. ALL                    ;OTHER SELECTED OUTPUT DEVICES WILL ECHO                    ;THE SCREEN OUTPUT.       JSR PRINTX   ;PUT PROMPT ON THE SCREEN:       .BYTE TEX    ;       .BYTE CR,LF,LF                ;       .BYTE 'SET STARTING ADDRESS ' ;       .BYTE 'TO KERNAL'             ;       .BYTE CR,LF                   ;       .BYTE ETX                     ;       ;JSR VISMON   ;CALL THE VISIBLE MONITOR, SO USER CAN       ;             ;SPECIFY A GIVEN ADDRESS.       LDA #<KERNAL ;       STA SELECT   ;       LDA #>KERNAL ;       STA SELECT+1 ;                    ;       JSR SAHERE   ;SET STARTING ADDRESS EQUAL TO ADDRESS SET                    ;BY THE USER.       JSR PRINTX   ;PUT PROMPT ON THE SCREEN:       .BYTE TEX       .BYTE CR,LF,LF       .BYTE 'SET ENDING ADDRESS '       .BYTE 'KEREND'        .BYTE CR,LF                   ;       .BYTE ETX       ;JSR VISMON   ;CALL THE VISIBLE MONITOR, SO USER CAN       ;             ;SPECIFY A GIVEN ADDRESS.       LDA #<KEREND ;       STA SELECT   ;       LDA #>KEREND ;       STA SELECT+1 ;                    ;       JSR EAHERE   ;                    ;       RTS          ;;********************************************;;;;********************************************.END