;********************************************;SYSTEM DATA BLOCK FOR THE COMMODORE 64;;APPENDIX C14: ASSEMBLER LISTING OF;SYSTEM DATA BLOCK;FOR THE COMMODORE 64;SEE APPENDIX B2 OF TOP-DOWN ASSEMBLY LANGUAGE;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20;BY KEN SKIER;COPYRIGHT (C) 1984 BY KENNETH SKIER;LEXINGTON, MASSACHUSETTS;;********************************************;********************************************;; C64 HARDWIRE MEMORY LOCATION DEFINITIONS;;********************************************KERNAL = $E000KEREND = $E0FFFRERAM = $C100FRETOP = $C1FFFREBOT = $C400;********************************************;; C64 ZEROPAGE STORAGE;;********************************************TVPTR  = $FB      ;POINTER TO CURRENT SCREEN                  ;LOCATION.GETPTR = $FD      ;PUTPTR = $FB      ;POINTER TO CURRENT SCREEN                  ;LOCATION.;********************************************;;EXTERNAL VECTORS;;********************************************;VISMON = $3207     ;TOP LEVEL OF THE VISIBLE;                   ;MONITOR.;HEXPG = $3500       ;ADDRESS OF PAGE IN WHICH;                   ;HEXDUMP CODE STARTS.;********************************************;;EXTERNAL MEMORY DEFINITIONS;;********************************************SA .WORD $E000EA .WORD $FFFF;********************************************;;C64 KERNAL ROUTINES;;********************************************CHKOUT = $FFC9CHROUT = $FFD2CLOSE  = $FFC3OPEN   = $FFC0SAVE   = $FFDBSETLFS = $FFBASETNAM = $FFBD;********************************************;;STARING ADDRESS DEFINTION;;********************************************;* = $3000;********************************************;;CONSTANTS DEFINITIONS;;********************************************TEX = $7F      ;THIS CHARACTER MUST START               ;ANY MESSAGE.ETX = $FF      ;THIS CHARACTER MUST               ;TERMINATE ANY MESSAGE STRING.;********************************************;;CHARACTER DEFINITIONS;;********************************************SPACE  = $20   ;ASCII FOR SPACE BAR.RUBOUT = $7F   ;ASCII FOR BACKSPACE ERASE.CR     = $0D   ;ASCII FOR CARRIAGE RETURN.LF     = $0A   ;ASCII FOR LINE FEED.CLRKEY = 147   ;CLEAR SCREEN KEY;********************************************;;SCREEN PARAMETERS;;********************************************HOME   .WORD $0400 ;THIS IS THE ADDRESS OF THE                   ;CHARACTER IN THE UPPER LEFT                   ;CORNER OF THE SCREEN. ROWINC .BYTE 40    ;ADDRESS DIFFERENCE FROM ONE                   ;ROW TO THE NEXT.TVCOLS .BYTE 39    ;NUMBER OF COLUMNS ON SCREEN,                   ;COUNTING FROM ZERO.TVROWS .BYTE 24    ;NUMBER OF ROWS ON SCREEN,                   ;COUNTING FROM ZERO.HIPAGE .BYTE $07   ;HIGHEST PAGE IN SCREEN MEMORY.BLANK  .BYTE $20   ;C64 DISPLAY CODE FOR A BLANK.                   ;(IN NORMAL VIDEO MODE.)ARROW  .BYTE $1E   ;C64 DISPLAY CODE FOR UP-ARROW.;********************************************;;INPUT/OUTPUT VECTORS;;********************************************ROMKEY .WORD C64KEY ;POINTER TO ROUTINE THAT GETS                    ;AN ASCII CHARACTER FROM THE                    ;KEYBOARD. (NOTES C64KEY                    ;CALLS A ROM SUBROUTINE, BUT                    ;C64KEY IS NOT A C64 ROM                    ;SUBROUTINE.)ROMTVT .WORD C64TVT ;POINTER TO ROUTINE TO PRINT                    ;PAN ASCII CHARACTER ON THE SCREENROMPRT .WORD C64PRT ;POINTER TO ROUTINE TO SEND AN                    ;ASCII CHARACTER TO THE PRINTERUSROUT .WORD DUMMY  ;POINTER TO USER-WRITTEN OUTPUT                    ;ROUTINE. (SET HERE TO DUMMY                    ;UNTIL YOU SET IT TO POINT                    ;TO YOUR OWN CHARACTER-OUTPUT                    ;ROUTINE.)DUMMY   RTS         ;THIS IS A DUMMY SUBROUTINE.                    ;IT DOES NOTHING BUT RETURN.;********************************************;CONVERT ASCII CHARACTER TO DISPLAY CODE;FIXCHR;;********************************************                   ;A CHARACTER IB IN A. WE                   ;MUST CONVERT IT TO PROPER                   ;C64 DISPLAY CODE.                   ;BUT FIRST, PUT A COLOR CODE                   ;IN APPROPRIATE BYTE OF                   ;COLOR MEMORY. (OTHERWISE,                   ;THAT BYTE IN COLOR MEMORY                   ;MIGHT BE ZERO, RENDERING                   ;THE CHARACTER INVISIBLE.)FIXCHR PHA          ;SAVE THE CHARACTER TO BE                    ;DISPLAYED.       LDA TVPTR+1  ;SAVE HIGH BYTE...       PHA          ;...OF TVPTR.       CLC          ;MAKE TVPTR POINT       ADC #$D4     ;TO APPROPRIATE BYTE       STA TVPTR+1  ;OF COLOR MEMORY.       LDY #0       ;       LDA $286     ;GET CURRENT COLOR CODE.                    ;STORE IT IN APPROPRIATE                    ;BYTE OF COLOR MEMORY:       STA (TVPTR),Y                    ;       PLA          ;RESTORE HIGH BYTE OF TV.PTR       STA TVPTR+1  ;TO ITS ORIGINAL VALUE.                    ;       PLA          ;RETRIEVE CHARACTER TO BE                    ;DISPLAYED.       SEC          ;PREPARE TO COMPARE.       CMP #$40     ;IS IT LESS THAN $40? (IS                    ;IT A NUMBER OR A PUNCTUATION                    ;MARK?).       BCC FIXEND   ;IF SO, NO CONVERSION NEEDED.                    ;       CMP #$60     ;IS IT IN THE RANGE $40...$5F?                    ;       BCC SUB40    ;IF SO, SUBTRACT $40 TO                    ;CONVERT FROM ASCII TO C64.                    ;IT'S > $5F.                    ;       SBC #$20     ;SUBTRACT $20 TO CONVERT                    ;LOWER CASE ASCII TO C64 CODE.                    ;       RTS          ;AND RETURN.                    ;SUB40  SEC          ;PREPARE TO SUBTRACT.       SBC #$40     ;SUBTRACT $40 TO CONVERT ASCII                    ;UPPERCASE CHAR TO C-64 CODE.FIXEND RTS          ;RETURN, WITH A HOLDING                    ;C-64 SCREEN CODE FOR ASCII                    ;CHAR ORIGINALLY IN A.;********************************************;;GET AN ASCII CHARACTER FROM THE KEYBOARD;;********************************************C64KEY JSR $FFE4   ;GET A KEYBOARD CHARACTER.       TAX         ;IS IT ZERO?       BEQ C64KEY  ;ZERO MEANS NO KEY, SO                   ;SCAN AGAIN.       RTS         ;RETURN WITH ASCII CHARACTER                   ;FROM THE KEYBOARD.;********************************************;;PRINT AN ASCII CHARACTER ON THE SCREEN;;********************************************C64TVT LDX #1     ;WE'LL DEFINE LOGICAL FILE #1                  ;AS AN OUTPUT CHANNEL.                  ;       JMP OUTCHR ;OUTPUT THE CHARACTER IN A ON                  ;LOGICAL FILE 'X'.;********************************************;;PRINT AN ASCII CHARACTER ON A PRINTER;;********************************************                  ;THIS PROCEDURE ASSUMES THAT                  ;THE USER HAS USED BASIC TO                  ;OPEN A DEVICE OR FILE AS                  ;LOGICAL FILE #2, BEFORE                  ;CALLING THE VJSIBLE MONITOR.                  ;LOGICAL FILE #2 MIGHT BE A                  ;PRINTER, OR THE RS-232 PORT,                  ;OR EVEN A DISK OR CASSETTE                  ;FILE. THE IMPORTANT THING IS                  ;THAT IT'S OPEN, SO WE MAY                  ;OUTPUT TEXT TO IT.                  ;C64PRT LDX #2     ;WE'LL DEFINE LOGICAL FILE #2                  ;AS AN OUTPUT CHANNEL.                  ;NOW OUTPUT CHARACTER IN A ON                  ;LOGICAL FILE 'X':OUTCHR PHA        ;SAVE CHARACTER TO BE OUTPUT.                  ;       JSR CHKOUT ;SET LOGICAL FILE 'X11 FOR OUTPUT.                   ;       PLA        ;RETRIEVE CHARACTER TO BE SENT.                  ;       JSR CHROUT ;OUTPUT CHARACTER IN A ON                  ;THE CURRENTLY-OPEN CHANNEL.                  ;       RTS        ;AND RETURN.;********************************************;;SAVE A MACHINE LANGUAGE PROGRAM;ON TAPE OR DISK;;********************************************                   ;THE FOLLOWING VARIABLES                   ;MUST BE SET, EITHER BY THE                   ;VISIBLE MONITOR OR BY A                   ;BASIC PROGRAM, BEFORE MLSAVE                   ;MAY BE CALLED.                   ;DEVICE .BYTE 1     ;DEVICE TO BE USED FOR SAVE.                   ;1 SPECIFIES DATASETTE.                   ;8 SPECIFIES DISK DRIVE.                   ;LENGTH .BYTE 0     ;LENGTH OF FILENAME.;NAME .BYTE 0,0,0,0 ;ROOM HERE     .BYTE 0,0,0,0 ;FILENAME OF UP TO 20 CHARACTERS.     .BYTE 0,0,0,0     .BYTE 0,0,0,0     .BYTE 0,0,0,0;NOTE: THE POINTERS SA AND EA;STARTING AND ENDING ADDRESSES;(RESPECTIVELY) OK THE PROGRAM;TO BE SAVED- THEY MAY BE SET;MOST CONVENIENTLY BY SIMPLY;CALLING THE SUBROUTINE 'SETADS';AT *35E3 (13795 DECIMAL).;STARTING AND ENDING ADDRESSES;(RESPECTIVELY) OK THE PROGRAM;TO BE SAVED- THEY MAY BE SET;MOST CONVENIENTLY BY SIMPLY;CALLING THE SUBROUTINE 'SETADS';AT *35E3 (13795 DECIMAL).MLSAVE LDA #3      ;LOGICAL FILE NUMBER.       LDX DEVICE  ;DEVICE NUMBER.       TAY         ;SECONDARY ADDRESS.       JSR SETLFS  ;CALL KERNAL ROUTINE 'SETLFS'.                   ;NOW THE C64 KNOWS WHAT DEVICE                   ;TO USE.                   ;       LDA LENGTH  ;GET LENGTH OF FILENAME.                   ;       LDX #<NAME       LDY #>NAME                   ;NOW (X,Y> POINTS TU THE FILE                   ;NAME.       JSR SETNAM  ;CALL KERNAL ROUTINE 'SETNAM'.                   ;NOW THE C64 KNOWS THE NAME OF                   ;THE FILE YOU WISH TO CREATE.                   ;       LDA SA       STA $FD       LDA SA+1       STA $FE    ;NOW PTR AT $FD POINTS TO START                  ;OF THE ML PROGRAM.       LDA #$FD   ;NOW A HOLDS ZERO PAGE OFFSET                  ;FOR THAT POINTER.       LDX EA     ;NOW (X,Y) POINTS TO THE END OF       LDY EA+1   ;THE ML PROGRAM.                  ;BUT THE KERNAL ROUTINE 'SAVE'                  ;REQUIRES THAT (X,Y) POINT ONE                  ;BYTE BEYOND THE END OF THE                  ;ML PROGRAM. SO INCREMENT                  ;(X,Y):       INX       BNE XYSET       INY        ;                  ;NOW (X,Y) IS SET.                  ;XYSET JSR SAVE   ;CALL KERNAL ROUTINE 'SAVE'.                  ;THIS ACTUALLY OPENS A FILE AND                  ;STORES THE SPECIFIED PORTION OF                  ;MEMORY ON THE SPECIFIED DEVICE.                  ;       RTS        ;RETURN TO CALLER (PRESUMABLY                  ;BASIC OR THE VISIBLE MONITOR;********************************************;;VISIBLE MONITOR:ENTRY FROM BASIC;;********************************************ENTRY  LDA #0      ;       PHA         ;       PLP         ;NOW THE STATUS REGISTER IS                   ;ZERO.                   ;                   ;OPEN THE SCREEN AS LOGICAL                   ;FILE #1:D                    ;       JSR SETNAM  ;A ALREADY HOLDS $00,                   ;INDICATING NO FILE NAME.                   ;       LDA #1      ;LOGICAL FILE NUMBER.       LDX #0      ;DEVICE NUMBER OF THE SCREEN.       LDY #255    ;(NO COMMAND.)       JSR SETLFS  ;C64 KERNAL ROUTINE 'SETLFS'                   ;       JSR OPEN    ;NOW THE SCREEN IS LOGICAL FILE                   ;#1.                   ;       JSR INTBUF  ;INITIALIZE TEXT EDITOR BUFFER                   ;       LDA #<HOME  ;INIT TVPRT WITH HOME SCREEN ADDRESS       STA TVPTR   ;       LDA #>HOME  ;       STA TVPTR+1 ;       LDA #<KERNAL ;INIT TVPRT WITH HOME SCREEN ADDRESS       STA SELECT   ;       LDA #>KERNAL ;       STA SELECT+1 ;       LDA #<KERNAL ;INIT TVPRT WITH HOME SCREEN ADDRESS       STA GETPTR   ;       LDA #>KERNAL ;       STA GETPTR+1 ;       JSR VISMON  ;CALL THE VISIBLE MONITOR.                   ;                   ;NOW THE VISIBLE MONITOR HAS                   ;RETURNED.                   ;       LDA #1      ;SO CLOSE LOGICAL FILE #1:       JSR CLOSE   ;                   ;       RTS         ;RETURN TO CALLER (PRESUMABLY                   ;BASIC.);********************************************;;;;********************************************.END