;********************************************;A SIMPLE TEXT EDITOR;;APPENDIX C10: ASSEMBLER LISTING OF ;A SIMPLE TEXT EDITOR (TOP ;LEVEL AND DISPLAY SUBROUTINES);SEE CHAPTER 11 OF TOP-DOWN ASSEMBLY LANGUAGE ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20;BY KEN SKIER;COPYRIGHT (C) 1984 BY KENNETH SKIER ;LEXINGTON,MASSACHUSETTS;;********************************************;********************************************;;CONSTANTS;;********************************************INSCHR = $49 ;'I'  ;GRAPHIC FOR INSERT MODEOVRCHR = $79 ;'O'  ;GRAPHIC FOR OVERSTRIKE MODE;********************************************;;VARIABLES;;********************************************;COUNTR .BYTE 0 ;COUNTER USED BY ELINE2.;EDMODE .BYTE 0 ;FLAG:0 FOR OVER STRIKE,               ;1 FOR INSERT.;********************************************;;TEXT EDITOR :TOP LEVEL;;********************************************EDITOR JSR SETBUF      ;INITIALIZ BUFFER POINTERS. EDLOOP JSR SHOWIT      ;SHOW USER A PORTION OF                        ;EDIT BUFFER.       JSR EDITIT      ;LET THE USER EDIT THE BUFFER                        ;OR MOVE ABOUT WITHIN IT.       CLC       BCC EDLOOP      ;LOOP BACK TO SHOW THE                        ;CURRENT TEXT;********************************************;;INITIALIZE BUFFER POINTERS;;********************************************SETBUF JSR TVTON       ;SELECT SCREEN.       JSR PRINTX      ;DISPLAY 'SET UP EDIT BUFFER.'       .BYTE TEX,CR,LF,LF       .BYTE 'SET UP EDIT BUFFER'       .BYTE CR,LF,LF,ETXGETADS JSR SETADS      ;LET USER SET LOCATION AND                       ;SIZE OF EDIT BUFFER       JSR GOTOSA      ;MAKE SELECT PT TO START OF                       ;BUFFER...       RTS             ;AND RETURN TO CALLER.;********************************************;;DISPLAY A PORTION OF EDIT BUFFER;;********************************************SHOWIT JSR TVPUSH  ;SAVE THE ZERO PAGE BYTES                    ;WE'LL USE.        JSR TVHOME  ;SET HOME POSITION OF EDIT                    ;DISPLAY                   ;       LDX TVCOLS  ;CLEAR THREE ROWS FOR       ;LDY #3      ;THE EDIT DISPLAY       LDY #4      ;THE EDIT DISPLAY       JSR CLRXY   ;                   ;       JSR TVHOME  ;RESTORE TV.PTR TO HOME                    ;POSITION OF THE EDIT DISPLAY.       JSR TVDOWN  ;SET TV.PTR TO BEGINNING       JSR TVPUSH  ;OF LINE TWO AND SAVE IT.       JSR ELINE2  ;DISPLAY TEXT IN LINE TWO.                   ;       JSR TVPOP   ;SET TV.PTR TO BEGINNING OF       JSR TVDOWN  ;THIRD LINE OF EDIT                   ;DISPLAY       JSR ELINE3  ;DISPLAY THIRD LINE OF EDIT                   ;DISPLAY                   ;       JSR TVPOP   ;RESTORE ZERO-PAGE BYTES USED.       RTS         ;RETURN TO CALLER, WITH EDIT                    ;DISPLAY ON SCREEN, REST OF                    ;SCREEN UNCHANGED, AND ZERO                   ;PAGE PRESERVED;********************************************;;ELINE2;;********************************************ELINE2 JSR PUSHSL  ;SAVE SELECT POINTER       LDA TVCOLS  ;SET X EQUAL TO       LSR A       ;HALF THE WIDTH       TAX         ;OF THE SCREEN       DEX         ;                   ;LOOPEL JSR DECSL   ;DECREMENT SELECT...       DEX         ;       BPL LOOPEL  ;...X TIMES.                   ;       LDA TVCOLS  ;INITIALIZE COUNTR.        STA COUNTR  ;(WE'RE DISPLAY TVCOLS                   ;CHARACTERS.)LOOPE2 JSR GETSL   ;GET A CHARACTER FROM BUFFER.       JSR TVPUT   ;PUT IT ON SCREEN.       JSR TVSKIP  ;GO TO NEXT SCREEN POSITION.       JSR INCSL   ;ADVANCE TO NEXT BYTE IN                    ;BUFFER       DEC COUNTR  ;DONE LAST CHARACTER IN ROW?       BPL LOOPE2  ;IF NOT, DO NEXT CHARACTER.                   ;       JSR POPSL   ;RESTORE SELECT FROM STACK.       RTS         ;RETURN TO CALLER.;********************************************;;DISPLAY STATUS LINE;;********************************************ELINE3 LDA TVCOLS   ;SELECT CENTER POSITION...        LSR A        ;NOW A IS TVCOLS/2       SBC #2       ;NOW A = (TVCOLS/2) - 2       JSR TVPLUS   ;NOW TV.PTR IS POINTING TWO                     ;CHARACTERS TO THE LEFT OF                     ;CENTER OF LINE 3 OF THE EDIT                    ;DISPLAY.       LDA EDMODE   ;WHAT IS CURRENT MODE?       CMP #1       ;IS IT INSERT MODE?       BNE OVMODE   ;IF NOT, IT MUST BE OVERSTRIKE                     ;MODE.       LDA #INSCHR  ;IF SO, GET INSERT GRAPHIC.       CLC          ;       BCC TVMODE   ;OVMODE LDA #OVRCHR  ;LOAD A W/OVERSTRIKE CHARACTER.TVMODE JSR TVPUT    ;PUT MODE GRAPHIC ON SCREEN       LDA #2       ;MOVE TWO POSITIONS TO THE       JSR TVPLUS   ;RIGHT, SO TVPTR POINTS TO                    ;CENTER OF LINE 3 OF EDIT                    ;DISPLAY       LDA ARROW    ;DISPLAY AN UP-ARROW HERE       JSR TVPUT    ;                    ;       LDA #2       ;GO TWO POSITIONS TO THE       JSR TVPLUS   ;RIGHT, SO TVPTR POINTS TO                    ;FIELD RESERVED FOR THE                    ;ADDRESS OF THE CURRENT CHARACTER       LDA SELECT+1 ;DISPLAY ADDRESS OF CURRENT       JSR VUBYTE   ;CHARACTER       LDA SELECT   ;       JSR VUBYTE   ;        RTS          ;RETURN TO CALLER;********************************************;APPENDIX Cll: ASSEMBLER LISTING OF ;A SIMPLE TEXT EDITOR ;EDITIT SUBROUTINE;SEE CHAPTER 11 OF TOP-DOWN ASSEMBLY LANGUAGE ;PROGRAMMING FOR YOUR COMMODORE 64 AND VIC-20;BY KEN SKIER;COPYRIGHT (C) 1984 BY KENNETH SKIER ;LEXINGTON, MASSACHUSETTS;********************************************;********************************************;;VARIABLES;;********************************************;EDIT FUNCTION KEYS;;THE EDITOR RECOGNIZES THE ;FOLLOWING KEYS AS FUNCTION KEYS. ;ASSIGN A FUNCTION TO A KEY ;BY STORING THE DESIRED KEY ;CODE FROM YOUR SYSTEM'S ;KEY HANDLER INTO ONE OF THE ;FOLLOWING DATA BYTES:;FLSHKY .BYTE $93   ;THIS KEY FLUSHES THE                    ;BUFFER OF ANY TEXT. $93 IS                    ;THE 'CLR' KEY. THUS,'CLR'                    ;TO FLUSH THE BUFFER.MODEKY .BYTE $94   ;THIS KEY CAUSES THE EDIT                    ;TO CHANGE MODES,FROM INSERT                    ;TO OVERSTRIKE, AND VICE VERSA.                    ;$94 IS 'INS' KEY. THUS,PRESS                    ;'INS' TO CHANG EMODES.NEXTKY .BYTE $1D   ;THIS KEY SELECTS THE NEXT                    ;CHARACTER IN THE BUFFER.                    ;$1D IS THE RIGHT-ARROW.                    ;THUS, PRESS RIGHT-ARROW TO                    ;MOVE TO THE RIGHT THROUGH                   ;THE TEX TBUFFER.PREVKY .BYTE $9D   ;THIS KEY SELECTS THE PREVIOUS                    ;CHARACTER IN THEBUFFER.                   ;$9D IS THE LEFT-ARROW.                    ;THUS, PRESS LEFT-ARROW TO                    ;MOVE TO THE LEFT THROUGH                    ;THE TEXT BUFFER.PRTKEY .BYTE $10   ;THIS KEY PRINTS THE BUFFER.                    ;$10 IS CONTROL-P. THUS,                    ;PRESS CONTROL-P TO PRINT                    ;THE BUFFER.RUBKEY .BYTE $14   ;THIS KEY RUBS OUT THE                    ;CURRENT CHARACTER. THUS, PRESS                    ;THE DELETE KEY TO DELETE THE                    ;CURRENT CHARACTER.QUITKY .BYTE 'Q'   ;TWO QUIT KEYS IN A ROW                    ;CAUSE THE EDITOR TO RETURN                    ;TO ITS CALLER.;OTHER VARIABLES:TEMPCH .BYTE 0      ;THIS BYTE USED BY EDITIT.;********************************************;;EDITIT;;********************************************EDITIT JSR GETKEY  ;GET A KEYSTROKE FROM THE USER.                   ;       CMP QUITKY  ;IS IT THE 'QUIT' KEY?       BNE DOKEY   ;IF NOT, DO WHAT THE KEY                    ;REQUIRES.                   ;       PHA         ;IF IT IS THE 'QUIT' KEY, SAVE       JSR GETKEY  ;IT AND GET A NEW KEY FROM                   ;USER       CMP QUITKY  ;IS THIS KEY A 'QUIT' KEY, TOO?       BNE NOTEND  ;IF NOT, THEN THIS IS NOT THE                    ;END OF THE EDIT SESSION.                   ;END THE EDIT SESSION?ENDEDT PLA         ;POP FIRST 'QUIT' KEY FROM                    ;STACK.       PLA         ;POP RETURN ADDRESS TO       PLA         ;THE EDITOR'S TOP LEVEL.       RTS         ;RETURN TO THE EDITOR'S CALLER.                   ;NOTEND STA TEMPCH  ;SAVE THE KEY THAT FOLLOWED                    ;THE 'QUIT' KEY.       PLA         ;POP FIRST 'QUIT' KEY FROM STACK.       JSR DOKEY   ;DO WHAT IT REQUIRES       LDA TEMPCH  ;RECOVER THE KEY THAT FOLLOWED                   ;THE 'QUIT' KEY.;                   ;'DOKEY ' DOES WHAT THE KEY                    ;IN THE ACCUMULATOR REQUIRES:                   ;DOKEY  CMP MODEKY  ;IS IT THE 'CHANGE MODE' KEY?       BNE IFNEXT  ;IF NOT, PERFORM THE NEXT TEST.       DEC EDMODE  ;IF SO, CHANGE THE EDITOR'S       BPL DOEND   ; MODE.       LDA #1      ;       STA EDMODE  ;DOEND  RTS         ;RETURN TO CALLER.                   ;IFNEXT CMP NEXTKY  ;IS IT THE 'NEXT' KEY?       BNE IFPREV  ;IF NOT, PERFORM NEXT TEST.                   ;       JSR NEXTEX  ;IF SO, ADVANCE TO NEXT                   ;CHARACTER...       RTS         ;...AND RETURN.                   ;IFPREV CMP PREVKY  ;IS IT THE 'PREVIOUS' KEY?       BNE IFRUB   ;IF NOT, PERFORM NEXT TEST.       JSR PREVSL  ;IF SO, BACK UP PREVIOUS       RTS         ;CHARACTER AND RETURN.                   ;IFRUB  CMP RUBKEY  ;IS IT THE 'RUBOUT' KEY?       BNE IFPRT   ;IF NOT, PERFORM NEXT TEST.       JSR DELETE  ;IF SO, DELETE THE CURRENT        RTS         ;CHARACTER AND RETURN.                   ;IFPRT  CMP PRTKEY  ;IS IT THE 'PRINT' KEY?       BNE IFFLSH  ;IF NOT, PERFORM NEXT TEST.       JSR PRTBUF  ;IF SO, PRINT THE BUFFER...       RTS         ;...AND RETURN.                   ;IFFLSH CMP FLSHKY  ;IS IT THE 'FLUSH' KEY?       BNE CHARKY  ;IF NOT, IT MUST BE A CHARACTER                   ;KEY       JSR FLUSH   ;IF SO, FLUSH THE BUFFER.       RTS         ;AND RETURN.                   ;                   ;OK. IT'S NOT AN EDITOR FUNCTION KEY, SO IT                   ;MUST BE A CHARACTER KEY. DEPENDING ON THE                   ;CURRENT MODE, WE'LL EITHER INSERT OF OVERSTRIKE                   ;THE CURRENT CHARACTER                   ;CHARKY LDX EDMODE  ;ARE WE IN OVERSTRIKE MODE?       BEQ STRIKE  ;IF SO, OVERSTRIKE THE                    ;CHARACTER.       JSR INSERT  ;IF NOT, INSERT THE CHARACTER.       RTS         ;RETURN.                   ;STRIKE JSR PUTSL   ;REPLACE CURRENT CHARACTER                   ;WITH NEW CHARACTER.                   ;THE CURRENT CHARACTER.       JSR NEXTSL  ;SELECT NEXT CHARRACTER,       RTS         ;RETURN                   ;INSERT PHA         ;SAVE THE CHARACTER TO BE                    ;INSERTED, WHILE WE MAKE ROOM                    ;FOR IT IN THE BUFFER...       JSR PUSHSL  ;SAVE THE CURRENT ADDRESS       LDA SA+1    ;SAVE THE BUFFER'S ADDRESS       PHA         ;       LDA SA      ;       PHA         ;                   ;       LDA EA+1    ;SAVE THE BUFFER'S END ADDRESS       PHA         ;       LDA EA      ;       PHA         ;                   ;       JSR SAHERE  ;SET SA EQUAL TO SELECT, SO                   ;CURRENT LOCATION WILL BE                   ;START OF THE BLOCK WE'LL                   ;MOVE                   ;       JSR NEXTSL  ;ADVANCE TO NEXT CHARACTER                   ;POSITION IN THE BUFFER.       BMI ENDINS  ;IF WE'RE AT THE END OF THE                    ;BUFFER, WE'LL OVERSTRIKE                    ;INSTEAD OF INSERTING.                   ;       JSR DAHERE  ;SET DEST EQUAL TO SELECT,                    ;DESTINATION OF BLOCK MOVE                    ;WILL BE ONE BYTE ABOVE                    ;BLOCK'SINITIAL LOCATION                   ;       LDA EA      ;DECREMENT END ADDRESS       BNE DECEA   ;       DEC EA+1    ;DECEA  DEC EA      ;                   ;OPENUP JSR MOVEA   ;OPEN UP ONE BYTE OF SPACE                    ;AT CURRENT CHARACTER'S                    ;LOCATION, BY MOVING TO DEST                   ;THE BLOCK SPECIFIED BY SA, EA.                   ;ENDINS PLA         ;RESTORE EA SO IT POINTS       STA EA      ;TO END OF BUFFER.       PLA         ;       STA EA+1    ;                   ;       PLA         ;RESTORE SA SO IT POINTS TO        STA SA      ;START OF BUFFER.       PLA         ;       STA SA+1    ;                   ;       JSR POPSL   ;RESTORE SELECT SO IT POINTS                    ;TO CURRENT CHARACTER POSITION.                   ;       PLA         ;RESTORE NEW CHARACTER TO                   ;ACCUMLATOR. WE'VE CREATED                   ;A ONE-BYTE SPACE FOR IT       RTS         ;AND RETURN;********************************************;;NEXTEX;;********************************************NEXTEX JSR GETSL   ;GET CURRENT CHARACTER.       CMP #ETX    ;IS IT END OF TEXT CHARACTER?       BEQ ANETX   ;IF SO, RETURN TO CALLER,                    ;BEARING A NEGATIVE RETURN CODE.                   ;       JSR NEXTSL  ;IF NOT, SELECT NEXT BYTE IN                    ;BUFFER       RTS         ;RETURN PLUS IF WE INCREMENTED                   ;SELECT; MINUS IF SELECT                    ;ALREADY EQUALED EA.                   ;ANETX  LDA #$FF    ;SINCE WE ARE ON AN ETX, WE        RTS         ;WILL RETURN WITH MINUS. WITHOUT                   ;INCREMENTING SELECT;********************************************;;PREVSL;;********************************************PREVSL SEC          ;PREPARE TO COMPARE.       LDA SA+1     ;IS SELECT IN A HIGHER PAGE       CMP SELECT+1 ;THAN START OF BUFFER?       BCC PLOK     ;IF SO, SELECT MAY BE DECREMENTED.       BNE NOTOK    ;IF SELECT IS IN A LOWER                     ;PAGE THAN SA, IT'S NOT OK.                    ;                    ;SELECT IS IN THE SAME PAGE AS SA.       LDA SA       ;IS SELECT>SA?       CMP SELECT   ;       BEQ NODEC    ;IF SELECT EQUALS SA, DON'T                     ;DECREMENT SELECT.       BCS NOTOK    ;IF SELECT<SA, DON'T DECREMENT                    ;SELECTPLOK   JSR DECSL    ;SELECT>SA, SO WE MAY                    ;DECREMENT SELECT AND IT                    ;WILL REMAIN IN THE BUFFER.       LDA #0       ;SET A POSITIVE RETURN CODE...       RTS          ;...AND RETURN.                     ;NOTOK  LDA SA       ;SINCE SELECT<SA, IT IS NOT       STA SELECT   ;EVEN IN THE EDIT BUFFER. SO       LDA SA+1     ;MAKE SELECT LEGAL VALUE, BY SETTING       STA SELECT+1 ;IT EQUAL TO SA.       LDA #0       ;SET A POSITIVE RETURN CODE...       RTS          ;...AND RETURN.                    ;NODEC  LDA #$FF     ;SELECT EQUALS SA, SO CHANGE        RTS          ;NOTHING. RETURN WITH                    ;NEGATIVE RETURN CODE.;********************************************;;FLUSH;;********************************************FLUSH  JSR GOTOSA  ;SET SELECT EQUAL TO SA. FLOOP  LDA #ETX    ;PUT AN ETX CHARACTER       JSR PUTSL   ;INTO THE BUFFER       JSR NEXTSL  ;ADVANCE TO NEXT POSITION IN                   ;BUFFER.       BPL FLOOP   ;IF WE HAVEN'T REACHED END                   ;OF BUFFER, PUT AN ETX INTO                   ;THIS POSITION, TOO.                   ;       JSR GOTOSA  ;HAVING FILLED BUFFER WITH                   ;ETX CHARACTERS, RESET SELECT                   ;TO BEGINNING OF BUFFER.       RTS         ;RETURN.;********************************************;;PRTBUF;;********************************************PRTBUF JSR GOTOSA  ;SET SELECT TO THE START OF BUFFER.       JSR PRON    ;SELECT PRINTER FOR OUTPUTPRLOOP JSR GETSL   ;GET THE CURRENT CHARACTER.       CMP #ETX    ;IS IT ETX?       BEQ ENDPRT  ;IF SO, WE'RE DONE.       JSR PRCHR   ;IF NOT, PRINT IT.       JSR NEXTSL  ;SELECT NEXT CHARACTER       BPL PRLOOP  ;IF WE HAVEN'T REACHED THE                   ;END OF THE BUFFER, HANDLE                   ;THE CURRENT CHARACTER AS BEFOREENDPRT JMP PROFF   ;HAVING REACHED END OF MESSAGE                   ;OR END OF BUFFER, RETURN TO                   ;CALLER OF EDITIT, DESELECTING                   ;THE PRINTER AS WE DONE.;********************************************;;DELETE;;********************************************DELETE JSR PUSHSL  ;SAVE CURRENT ADDRESS       LDA SA+1    ;SAVE BUFFER'S START ADDRESS.       PHA         ;       LDA SA      ;       PHA         ;                   ;       JSR DAHERE  ;SET DEST EQUAL SELECT,                    ;BECAUSE WE'LL MOVE A BLOCK OF                    ;TEXT DOWN TO HERE, TO ;CLOSE UP                    ;THE BUFFER AT THE CURRENT                   ;CHARACTER.       JSR NEXTSL  ;ADVANCE BY ONE BYTE THROUGH                   ;BUFFER, IF POSSIBLE.       JSR SAHERE  ;SET SA EQUAL TO SELECT, BECAUSE                    ;THIS IS THE START OF THE BLOCK                   ;WE'LL MOVE DOWN.                   ;NOTE: THE END ADDRESS OF                   ;THE BLOCK IS THE END ADDRESS                   ;OF THE TEXT BUFFER.)       JSR MOVEA   ;MOVE BLOCK SPECIFIED BY                    ;SA, EA, AND DEST.                   ;       PLA         ;RESTORE INITIAL SA (WHICH       STA SA      ;IS THE START ADDRESS OF THE       PLA         ;TEXT BUFFER, NOT OF THE BLOCK       STA SA+1    ;WE JUST MOVED).                   ;       JSR POPSL   ;RESTORE CURRENT ADDRESS       RTS         ;RETURN TO CALLER.;********************************************;; ADDED CODE;;********************************************;********************************************;; FILL TEXT BUFFER WITH START OF TEXT AND; END OF TEXT MARKERS;;********************************************INTBUF =*         LDA #<FRERAM        STA PUTPTR        LDA #>FRERAM        STA PUTPTR+1;       LDY #$00       LDA #TEX       STA (PUTPTR),Y       INY;       LDA #ETXIL     STA (PUTPTR),Y       INY       BNE IL;       RTS      ;********************************************;;;;********************************************.END